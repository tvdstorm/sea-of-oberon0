// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 1.14.4,
// (C) 2004-2009 Robert Grimm,
// on Saturday, March 5, 2011 at 6:26:27 PM.
// Edit at your own risk.
// ===========================================================================

package eu.wietsevenema.lang.oberon.parser;

import java.io.Reader;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.OutputStreamWriter;
import java.io.IOException;

import xtc.util.Pair;

import xtc.tree.Locatable;
import xtc.tree.Node;
import xtc.tree.GNode;
import xtc.tree.Printer;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

import eu.wietsevenema.lang.oberon.ast.declarations.*;
import eu.wietsevenema.lang.oberon.ast.expressions.*;
import eu.wietsevenema.lang.oberon.ast.statements.*;
import eu.wietsevenema.lang.oberon.ast.types.*;

import java.util.ArrayList;
import java.util.List;

import xtc.util.Action;

/**
 * Packrat parser for grammar <code>eu.wietsevenema.lang.oberon.parser.Oberon</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 1.14.4, (C) 2004-2009 Robert Grimm.
 */
public final class Oberon extends ParserBase {

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result feu$wietsevenema$lang$oberon$parser$Symbol$Symbol;
    Result fIdentifier;
    Result fIdentList;
    Result fIdentList$$Star1;
    Result fWord;
    Result fFactor;
    Result fSelector;
    Result fSelector$$Star1;
    Result fTerm;
    Result fTerm$$Star1;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fSimpleExpression;
    Result fSimpleExpression$$Star1;
    Result fExpression;
    Result fStatementSequence;
    Result fStatementSequence$$Star1;
    Result fStatement;
    Result fDeclarations;
    Result fDeclarations$$Star1;
    Result fType;
    Result fFieldList;
  }

  /** Chunk 3 of memoized results. */
  static final class Chunk3 {
    Result fFPSection;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class OberonColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
    Chunk3 chunk3;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public Oberon(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public Oberon(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new OberonColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal eu.wietsevenema.lang.oberon.parser.Oberon.Program.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pProgram(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pModule(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pEndOfFile(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Oberon.TestExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pTestExpression(final int yyStart) throws IOException {
    Result         yyResult;
    TestExpression yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression exp = yyResult.semanticValue();

        yyResult = pEndOfFile(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue= new TestExpression(exp);

          if (yyValue instanceof Locatable) {
            setLocation((Locatable)yyValue, yyStart);
          }
          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal eu.wietsevenema.lang.oberon.parser.Symbol.Symbol.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(final int yyStart) 
    throws IOException {

    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.feu$wietsevenema$lang$oberon$parser$Symbol$Symbol) 
      yyColumn.chunk1.feu$wietsevenema$lang$oberon$parser$Symbol$Symbol = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol$1(yyStart);
    return yyColumn.chunk1.feu$wietsevenema$lang$oberon$parser$Symbol$Symbol;
  }

  /** Actually parse eu.wietsevenema.lang.oberon.parser.Symbol.Symbol. */
  private Result peu$wietsevenema$lang$oberon$parser$Symbol$Symbol$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = 
      peu$wietsevenema$lang$oberon$parser$Symbol$SymbolCharacters(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Symbol.SymbolCharacters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result peu$wietsevenema$lang$oberon$parser$Symbol$SymbolCharacters(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '>':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '>':
              {
                final int yyChoice2 = yyIndex;

                // Nested alternative 1.

                yyC = character(yyChoice2);
                if (-1 != yyC) {
                  yyIndex = yyChoice2 + 1;
                  if ('=' == yyC) {

                    yyValue = ">>=";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }

                // Nested alternative 2.

                yyValue = ">>";

                return new SemanticValue(yyValue, yyChoice2, yyError);
              }

            case '=':
              {
                yyValue = ">=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = ">";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '<':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '<':
              {
                final int yyChoice2 = yyIndex;

                // Nested alternative 1.

                yyC = character(yyChoice2);
                if (-1 != yyC) {
                  yyIndex = yyChoice2 + 1;
                  if ('=' == yyC) {

                    yyValue = "<<=";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }

                // Nested alternative 2.

                yyValue = "<<";

                return new SemanticValue(yyValue, yyChoice2, yyError);
              }

            case '=':
              {
                yyValue = "<=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = "<";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case 'D':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('I' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('V' == yyC) {

                  yyValue = "DIV";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }
        }
        break;

      case 'M':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('O' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('D' == yyC) {

                  yyValue = "MOD";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }
        }
        break;

      case 'O':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('R' == yyC) {

              yyValue = "OR";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '#':
        {
          yyValue = "#";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ':':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = ":=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = ":";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '+':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '=':
              {
                yyValue = "+=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '+':
              {
                yyValue = "++";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = "+";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '-':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '=':
              {
                yyValue = "-=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '-':
              {
                yyValue = "--";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = "-";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '*':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "*=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "*";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '/':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "/=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "/";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '%':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "%=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "%";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '&':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '=':
              {
                yyValue = "&=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '&':
              {
                yyValue = "&&";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = "&";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '^':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "^=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "^";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '|':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '=':
              {
                yyValue = "|=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '|':
              {
                yyValue = "||";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = "|";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '=':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "==";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "=";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '!':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "!=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "!";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case ';':
        {
          yyValue = ";";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ',':
        {
          yyValue = ",";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '.':
        {
          yyValue = ".";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '{':
        {
          yyValue = "{";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '}':
        {
          yyValue = "}";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '(':
        {
          yyValue = "(";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ')':
        {
          yyValue = ")";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '[':
        {
          yyValue = "[";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ']':
        {
          yyValue = "]";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '~':
        {
          yyValue = "~";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '?':
        {
          yyValue = "?";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("symbol characters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Identifier.Identifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentifier(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fIdentifier) 
      yyColumn.chunk1.fIdentifier = pIdentifier$1(yyStart);
    return yyColumn.chunk1.fIdentifier;
  }

  /** Actually parse eu.wietsevenema.lang.oberon.parser.Identifier.Identifier. */
  private Result pIdentifier$1(final int yyStart) throws IOException {
    Result     yyResult;
    Identifier yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pVariableName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String vn = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = new Identifier(vn);

        if (yyValue instanceof Locatable) {
          setLocation((Locatable)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Identifier.IdentList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentList(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fIdentList) 
      yyColumn.chunk1.fIdentList = pIdentList$1(yyStart);
    return yyColumn.chunk1.fIdentList;
  }

  /** Actually parse eu.wietsevenema.lang.oberon.parser.Identifier.IdentList. */
  private Result pIdentList$1(final int yyStart) throws IOException {
    Result           yyResult;
    List<Identifier> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Identifier i = yyResult.semanticValue();

      yyResult = pIdentList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Identifier> is = yyResult.semanticValue();

        yyValue = new Pair<Identifier>(i, is).list();

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Oberon.IdentList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentList$$Star1(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fIdentList$$Star1) 
      yyColumn.chunk1.fIdentList$$Star1 = pIdentList$$Star1$1(yyStart);
    return yyColumn.chunk1.fIdentList$$Star1;
  }

  /** Actually parse eu.wietsevenema.lang.oberon.parser.Oberon.IdentList$$Star1. */
  private Result pIdentList$$Star1$1(final int yyStart) throws IOException {
    Result           yyResult;
    Pair<Identifier> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pxtc$util$Symbol$Symbol(yyStart);
    if (yyResult.hasValue(",")) {

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Identifier v$el$1 = yyResult.semanticValue();

        yyResult = pIdentList$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Identifier> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Identifier>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Identifier.VariableName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVariableName(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyRepetition1 = yyIndex;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;
            if ((('0' <= yyC) && (yyC <= '9')) ||
                (('A' <= yyC) && (yyC <= 'Z')) ||
                (('a' <= yyC) && (yyC <= 'z'))) {

              yyRepetition1 = yyIndex;
              continue;
            }
          }
          break;
        }

        yyValue = difference(yyStart, yyRepetition1);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("variable name expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Identifier.DecimalNumeral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecimalNumeral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
        {
          yyValue = "0";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyRepetition1 = yyIndex;
          while (true) {

            yyC = character(yyRepetition1);
            if (-1 != yyC) {
              yyIndex = yyRepetition1 + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
                {
                  yyRepetition1 = yyIndex;
                  continue;
                }

              default:
                /* No match. */
              }
            }
            break;
          }

          yyValue = difference(yyStart, yyRepetition1);

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("decimal numeral expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal eu.wietsevenema.lang.oberon.parser.Identifier.Word.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWord(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fWord) 
      yyColumn.chunk1.fWord = pWord$1(yyStart);
    return yyColumn.chunk1.fWord;
  }

  /** Actually parse eu.wietsevenema.lang.oberon.parser.Identifier.Word. */
  private Result pWord$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWordCharacters(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Identifier.WordCharacters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWordCharacters(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if (('A' <= yyC) && (yyC <= 'Z')) {

        yyRepetition1 = yyIndex;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;
            if ((('0' <= yyC) && (yyC <= '9')) ||
                (('A' <= yyC) && (yyC <= 'Z'))) {

              yyRepetition1 = yyIndex;
              continue;
            }
          }
          break;
        }

        yyValue = difference(yyStart, yyRepetition1);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("word characters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal eu.wietsevenema.lang.oberon.parser.Expression.Factor.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFactor(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fFactor) 
      yyColumn.chunk1.fFactor = pFactor$1(yyStart);
    return yyColumn.chunk1.fFactor;
  }

  /** Actually parse eu.wietsevenema.lang.oberon.parser.Expression.Factor. */
  private Result pFactor$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Constant>.

    yyResult = pConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <ParenthesizedExpression>.

    yyResult = pParenthesizedExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <LogicalNegation>.

    yyResult = pLogicalNegationExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Selector>.

    yyResult = pSelector(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Expression.LogicalNegationExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalNegationExpression(final int yyStart) 
    throws IOException {

    Result                    yyResult;
    LogicalNegationExpression yyValue;
    ParseError                yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyStart);
    if (yyResult.hasValue("~")) {

      yyResult = pFactor(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression f = yyResult.semanticValue();

        yyValue = new LogicalNegationExpression((Expression)f);

        if (yyValue instanceof Locatable) {
          setLocation((Locatable)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("logical negation expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal eu.wietsevenema.lang.oberon.parser.Expression.Selector.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSelector(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fSelector) 
      yyColumn.chunk1.fSelector = pSelector$1(yyStart);
    return yyColumn.chunk1.fSelector;
  }

  /** Actually parse eu.wietsevenema.lang.oberon.parser.Expression.Selector. */
  private Result pSelector$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Identifier seed = yyResult.semanticValue();

      yyResult = pSelector$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Action<Expression>> actions = yyResult.semanticValue();

        yyValue = apply(actions,seed);

        if (yyValue instanceof Locatable) {
          setLocation((Locatable)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Oberon.Selector$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSelector$$Star1(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fSelector$$Star1) 
      yyColumn.chunk1.fSelector$$Star1 = pSelector$$Star1$1(yyStart);
    return yyColumn.chunk1.fSelector$$Star1;
  }

  /** Actually parse eu.wietsevenema.lang.oberon.parser.Oberon.Selector$$Star1. */
  private Result pSelector$$Star1$1(final int yyStart) throws IOException {
    Result                   yyResult;
    Pair<Action<Expression>> yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSelectorTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Action<Expression> v$el$1 = yyResult.semanticValue();

      yyResult = pSelector$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Action<Expression>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<Expression>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Expression.SelectorTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSelectorTail(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyBase;
    Action<Expression> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyStart);
    if (yyResult.hasValue("[")) {

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression right = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
        if (yyResult.hasValue("]")) {

          yyValue = new Action<Expression>(){
            public Expression run(Expression left){
              Expression result = new ArraySelector(left, right);
              result.setLocation(location(yyStart));
              return result;
            }
          };

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      }
    }

    // Alternative 2.

    yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyStart);
    if (yyResult.hasValue(".")) {

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Identifier key = yyResult.semanticValue();

        yyValue = new Action<Expression>(){
          public Expression run(Expression left){
            Expression result = new RecordSelector(left, key);
            result.setLocation(location(yyStart));
            return result;
          }
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("selector tail expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Expression.ParenthesizedExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParenthesizedExpression(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
        if (yyResult.hasValue(")")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("parenthesized expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal eu.wietsevenema.lang.oberon.parser.Expression.Constant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConstant(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIntegerConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pBooleanConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal eu.wietsevenema.lang.oberon.parser.Expression.Term.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTerm(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fTerm) 
      yyColumn.chunk1.fTerm = pTerm$1(yyStart);
    return yyColumn.chunk1.fTerm;
  }

  /** Actually parse eu.wietsevenema.lang.oberon.parser.Expression.Term. */
  private Result pTerm$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFactor(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression seed = yyResult.semanticValue();

      yyResult = pTerm$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Action<Expression>> actions = yyResult.semanticValue();

        yyValue = apply(actions, seed);

        setLocation(yyValue, yyStart);
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Oberon.Term$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTerm$$Star1(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fTerm$$Star1) 
      yyColumn.chunk1.fTerm$$Star1 = pTerm$$Star1$1(yyStart);
    return yyColumn.chunk1.fTerm$$Star1;
  }

  /** Actually parse eu.wietsevenema.lang.oberon.parser.Oberon.Term$$Star1. */
  private Result pTerm$$Star1$1(final int yyStart) throws IOException {
    Result                   yyResult;
    Pair<Action<Expression>> yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTermTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Action<Expression> v$el$1 = yyResult.semanticValue();

      yyResult = pTerm$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Action<Expression>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<Expression>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal eu.wietsevenema.lang.oberon.parser.Expression.TermTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTermTail(final int yyStart) throws IOException {
    Result             yyResult;
    Action<Expression> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyStart);
    if (yyResult.hasValue("*")) {

      yyResult = pFactor(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression right = yyResult.semanticValue();

        yyValue = new Action<Expression>(){
          public Expression run(Expression left){
            Expression result = new MultiplicativeExpression(left, right);
            result.setLocation(location(yyStart));
            return result;
          }
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyStart);
    if (yyResult.hasValue("DIV")) {

      yyResult = pFactor(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression right = yyResult.semanticValue();

        yyValue = new Action<Expression>(){
          public Expression run(Expression left){
            Expression result = new DivisiveExpression(left, right);
            result.setLocation(location(yyStart));
            return result;
          }
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyStart);
    if (yyResult.hasValue("MOD")) {

      yyResult = pFactor(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression right = yyResult.semanticValue();

        yyValue = new Action<Expression>(){
          public Expression run(Expression left){
            Expression result = new ModulusExpression(left, right);
            result.setLocation(location(yyStart));
            return result;
          }
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyStart);
    if (yyResult.hasValue("&")) {

      yyResult = pFactor(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression right = yyResult.semanticValue();

        yyValue = new Action<Expression>(){
          public Expression run(Expression left){
            Expression result = new LogicalConjunctiveExpression(left, right);
            result.setLocation(location(yyStart));
            return result;
          }
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("term tail expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Expression.SimpleExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleExpression(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fSimpleExpression) 
      yyColumn.chunk2.fSimpleExpression = pSimpleExpression$1(yyStart);
    return yyColumn.chunk2.fSimpleExpression;
  }

  /** Actually parse eu.wietsevenema.lang.oberon.parser.Expression.SimpleExpression. */
  private Result pSimpleExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pUnaryPlusMin(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression seed = yyResult.semanticValue();

      yyResult = pSimpleExpression$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Action<Expression>> actions = yyResult.semanticValue();

        yyValue = apply(actions,seed);

        if (yyValue instanceof Locatable) {
          setLocation((Locatable)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Oberon.SimpleExpression$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleExpression$$Star1(final int yyStart) 
    throws IOException {

    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fSimpleExpression$$Star1) 
      yyColumn.chunk2.fSimpleExpression$$Star1 = pSimpleExpression$$Star1$1(yyStart);
    return yyColumn.chunk2.fSimpleExpression$$Star1;
  }

  /** Actually parse eu.wietsevenema.lang.oberon.parser.Oberon.SimpleExpression$$Star1. */
  private Result pSimpleExpression$$Star1$1(final int yyStart) 
    throws IOException {

    Result                   yyResult;
    Pair<Action<Expression>> yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSimpleExpressionTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Action<Expression> v$el$1 = yyResult.semanticValue();

      yyResult = pSimpleExpression$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Action<Expression>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<Expression>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Expression.SimpleExpressionTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleExpressionTail(final int yyStart) throws IOException {
    Result             yyResult;
    Action<Expression> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyStart);
    if (yyResult.hasValue("+")) {

      yyResult = pTerm(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node right = yyResult.semanticValue();

        yyValue = new Action<Expression>(){
          public Expression run(Expression left){
            Expression result = new AdditiveExpression(left, (Expression) right);
            result.setLocation(location(yyStart));
            return result;
          }
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyStart);
    if (yyResult.hasValue("-")) {

      yyResult = pTerm(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node right = yyResult.semanticValue();

        yyValue = new Action<Expression>(){
          public Expression run(Expression left){
            Expression result = new SubtractiveExpression(left, (Expression) right);
            result.setLocation(location(yyStart));
            return result;
          }
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyStart);
    if (yyResult.hasValue("OR")) {

      yyResult = pTerm(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node right = yyResult.semanticValue();

        yyValue = new Action<Expression>(){
          public Expression run(Expression left){
            Expression result = new LogicalDisjunctiveExpression(left, (Expression) right);
            result.setLocation(location(yyStart));
            return result;
          }
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("simple expression tail expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Expression.UnaryPlusMin.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnaryPlusMin(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyStart);
    if (yyResult.hasValue("-")) {

      yyResult = pTerm(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node ue = yyResult.semanticValue();

        yyValue = new UnaryMinExpression((Expression)ue);

        if (yyValue instanceof Locatable) {
          setLocation((Locatable)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyStart);
    if (yyResult.hasValue("+")) {

      yyResult = pTerm(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pTerm(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("unary plus min expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Expression.Expression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fExpression) 
      yyColumn.chunk2.fExpression = pExpression$1(yyStart);
    return yyColumn.chunk2.fExpression;
  }

  /** Actually parse eu.wietsevenema.lang.oberon.parser.Expression.Expression. */
  private Result pExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSimpleExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression left = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
      if (yyResult.hasValue("=")) {

        yyResult = pSimpleExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expression right = yyResult.semanticValue();

          yyValue = new EqualityExpression(left, right);

          if (yyValue instanceof Locatable) {
            setLocation((Locatable)yyValue, yyStart);
          }
          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'=' expected", yyBase);
      }

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
      if (yyResult.hasValue("#")) {

        yyResult = pSimpleExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expression right = yyResult.semanticValue();

          yyValue = new NotExpression(left, right);

          if (yyValue instanceof Locatable) {
            setLocation((Locatable)yyValue, yyStart);
          }
          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'#' expected", yyBase);
      }

      // Nested alternative 3.

      yyBase   = yyChoice1;
      yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
      if (yyResult.hasValue("<")) {

        yyResult = pSimpleExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expression right = yyResult.semanticValue();

          yyValue = new LessExpression(left, right);

          if (yyValue instanceof Locatable) {
            setLocation((Locatable)yyValue, yyStart);
          }
          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'<' expected", yyBase);
      }

      // Nested alternative 4.

      yyBase   = yyChoice1;
      yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
      if (yyResult.hasValue("<=")) {

        yyResult = pSimpleExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expression right = yyResult.semanticValue();

          yyValue = new LessOrEqualExpression(left, right);

          if (yyValue instanceof Locatable) {
            setLocation((Locatable)yyValue, yyStart);
          }
          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'<=' expected", yyBase);
      }

      // Nested alternative 5.

      yyBase   = yyChoice1;
      yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
      if (yyResult.hasValue(">")) {

        yyResult = pSimpleExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expression right = yyResult.semanticValue();

          yyValue = new GreaterExpression(left, right);

          if (yyValue instanceof Locatable) {
            setLocation((Locatable)yyValue, yyStart);
          }
          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'>' expected", yyBase);
      }

      // Nested alternative 6.

      yyBase   = yyChoice1;
      yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
      if (yyResult.hasValue(">=")) {

        yyResult = pSimpleExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expression right = yyResult.semanticValue();

          yyValue = new GreaterOrEqualExpression(left, right);

          if (yyValue instanceof Locatable) {
            setLocation((Locatable)yyValue, yyStart);
          }
          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'>=' expected", yyBase);
      }
    }

    // Alternative 2.

    yyResult = pSimpleExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Expression.IntegerConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntegerConstant(final int yyStart) throws IOException {
    Result          yyResult;
    IntegerConstant yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDecimalNumeral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String nr = yyResult.semanticValue();

      try {
        yyValue = new IntegerConstant(Integer.decode(nr));
      } catch (NumberFormatException x) {
        yyValue = null;
      }

      if (yyValue instanceof Locatable) {
        setLocation((Locatable)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Expression.BooleanConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBooleanConstant(final int yyStart) throws IOException {
    Result          yyResult;
    BooleanConstant yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("TRUE")) {

      yyValue = new BooleanConstant( Boolean.TRUE );

      if (yyValue instanceof Locatable) {
        setLocation((Locatable)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("FALSE")) {

      yyValue = new BooleanConstant( Boolean.FALSE );

      if (yyValue instanceof Locatable) {
        setLocation((Locatable)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("boolean constant expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Statement.StatementSequence.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStatementSequence(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fStatementSequence) 
      yyColumn.chunk2.fStatementSequence = pStatementSequence$1(yyStart);
    return yyColumn.chunk2.fStatementSequence;
  }

  /** Actually parse eu.wietsevenema.lang.oberon.parser.Statement.StatementSequence. */
  private Result pStatementSequence$1(final int yyStart) throws IOException {
    Result          yyResult;
    List<Statement> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Statement statement = yyResult.semanticValue();

      yyResult = pStatementSequence$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Statement> statements = yyResult.semanticValue();

        yyValue = new Pair<Statement>(statement, statements).list();

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Oberon.StatementSequence$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStatementSequence$$Star1(final int yyStart) 
    throws IOException {

    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fStatementSequence$$Star1) 
      yyColumn.chunk2.fStatementSequence$$Star1 = pStatementSequence$$Star1$1(yyStart);
    return yyColumn.chunk2.fStatementSequence$$Star1;
  }

  /** Actually parse eu.wietsevenema.lang.oberon.parser.Oberon.StatementSequence$$Star1. */
  private Result pStatementSequence$$Star1$1(final int yyStart) 
    throws IOException {

    Result          yyResult;
    Pair<Statement> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyStart);
    if (yyResult.hasValue(";")) {

      yyResult = pStatement(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Statement v$el$1 = yyResult.semanticValue();

        yyResult = pStatementSequence$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Statement> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Statement>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Statement.ProcedureCallStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pProcedureCallStatement(final int yyStart) 
    throws IOException {

    Result                 yyResult;
    int                    yyBase;
    int                    yyOption1;
    List<Expression>       yyOpValue1;
    int                    yyOption2;
    List<Expression>       yyOpValue2;
    ProcedureCallStatement yyValue;
    ParseError             yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Identifier id = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyBase   = yyOption1;
      yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyOption2  = yyResult.index;
        yyOpValue2 = null;

        yyResult = pActualParameters(yyOption2);
        yyError  = yyResult.select(yyError, yyOption2);
        if (yyResult.hasValue()) {
          final List<Expression> v$el$2 = yyResult.semanticValue();

          yyOption2  = yyResult.index;
          yyOpValue2 = v$el$2;
        }
        { // Start scope for v$el$1.
          final List<Expression> v$el$1 = yyOpValue2;

          yyBase   = yyOption2;
          yyResult = 
            peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        } // End scope for v$el$1.
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
      { // Start scope for params.
        final List<Expression> params = yyOpValue1;

        yyValue = new ProcedureCallStatement(id, params);

        if (yyValue instanceof Locatable) {
          setLocation((Locatable)yyValue, yyStart);
        }
        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for params.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Statement.ActualParameters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pActualParameters(final int yyStart) throws IOException {
    Result           yyResult;
    int              yyBase;
    int              yyRepetition1;
    Pair<Expression> yyRepValue1;
    List<Expression> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression act = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pExpression(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Expression v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Expression>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for acts.
        final Pair<Expression> acts = yyRepValue1.reverse();

        yyValue = new Pair<Expression>(act, acts).list();

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for acts.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Statement.ElseIfStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElseIfStatement(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyBase;
    ElseIfStatement yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("ELSIF")) {

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression cond = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pWord(yyBase);
        if (yyResult.hasValue("THEN")) {

          yyResult = pStatementSequence(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final List<Statement> truestats = yyResult.semanticValue();

            yyValue = new ElseIfStatement( cond, truestats );

            if (yyValue instanceof Locatable) {
              setLocation((Locatable)yyValue, yyStart);
            }
            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("'THEN' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("else if statement expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Statement.WithStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWithStatement(final int yyStart) throws IOException {
    Result        yyResult;
    int           yyBase;
    WithStatement yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("WITH")) {

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression record = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pWord(yyBase);
        if (yyResult.hasValue("DO")) {

          yyResult = pStatementSequence(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final List<Statement> stats = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pWord(yyBase);
            if (yyResult.hasValue("END")) {

              yyValue = new WithStatement( record, stats);

              if (yyValue instanceof Locatable) {
                setLocation((Locatable)yyValue, yyStart);
              }
              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("'END' expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("'DO' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("with statement expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Statement.IfStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIfStatement(final int yyStart) throws IOException {
    Result                yyResult;
    int                   yyBase;
    int                   yyRepetition1;
    Pair<ElseIfStatement> yyRepValue1;
    int                   yyOption1;
    List<Statement>       yyOpValue1;
    IfStatement           yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("IF")) {

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression cond = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pWord(yyBase);
        if (yyResult.hasValue("THEN")) {

          yyResult = pStatementSequence(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final List<Statement> truestats = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = Pair.empty();
            while (true) {

              yyResult = pElseIfStatement(yyRepetition1);
              yyError  = yyResult.select(yyError, yyRepetition1);
              if (yyResult.hasValue()) {
                final ElseIfStatement v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = 
                  new Pair<ElseIfStatement>(v$el$1, yyRepValue1);
                continue;
              }
              break;
            }
            { // Start scope for elseifs.
              final Pair<ElseIfStatement> elseifs = yyRepValue1.reverse();

              yyOption1  = yyRepetition1;
              yyOpValue1 = null;

              yyBase   = yyOption1;
              yyResult = pWord(yyBase);
              if (yyResult.hasValue("ELSE")) {

                yyResult = pStatementSequence(yyResult.index);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {
                  final List<Statement> v$el$2 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$2;
                }
              } else {
                yyError = yyError.select("'ELSE' expected", yyBase);
              }
              { // Start scope for falsestats.
                final List<Statement> falsestats = yyOpValue1;

                yyBase   = yyOption1;
                yyResult = pWord(yyBase);
                if (yyResult.hasValue("END")) {

                  yyValue = new IfStatement( cond, truestats, elseifs.list(), falsestats);

                  if (yyValue instanceof Locatable) {
                    setLocation((Locatable)yyValue, yyStart);
                  }
                  return yyResult.createValue(yyValue, yyError);
                } else {
                  yyError = yyError.select("'END' expected", yyBase);
                }
              } // End scope for falsestats.
            } // End scope for elseifs.
          }
        } else {
          yyError = yyError.select("'THEN' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("if statement expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Statement.WhileStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhileStatement(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyBase;
    WhileStatement yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("WHILE")) {

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression cond = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pWord(yyBase);
        if (yyResult.hasValue("DO")) {

          yyResult = pStatementSequence(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final List<Statement> stats = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pWord(yyBase);
            if (yyResult.hasValue("END")) {

              yyValue = new WhileStatement( cond, stats );

              if (yyValue instanceof Locatable) {
                setLocation((Locatable)yyValue, yyStart);
              }
              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("'END' expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("'DO' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("while statement expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal eu.wietsevenema.lang.oberon.parser.Statement.Statement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStatement(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fStatement) 
      yyColumn.chunk2.fStatement = pStatement$1(yyStart);
    return yyColumn.chunk2.fStatement;
  }

  /** Actually parse eu.wietsevenema.lang.oberon.parser.Statement.Statement. */
  private Result pStatement$1(final int yyStart) throws IOException {
    Result     yyResult;
    Statement  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAssignmentStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pWhileStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pIfStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pWithStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pProcedureCallStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Statement.AssignmentStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssignmentStatement(final int yyStart) throws IOException {
    Result              yyResult;
    int                 yyBase;
    AssignmentStatement yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSelector(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression id = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
      if (yyResult.hasValue(":=")) {

        yyResult = pExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expression exp = yyResult.semanticValue();

          yyValue= new AssignmentStatement(id, exp);

          if (yyValue instanceof Locatable) {
            setLocation((Locatable)yyValue, yyStart);
          }
          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("':=' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Declaration.Declarations.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarations(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fDeclarations) 
      yyColumn.chunk2.fDeclarations = pDeclarations$1(yyStart);
    return yyColumn.chunk2.fDeclarations;
  }

  /** Actually parse eu.wietsevenema.lang.oberon.parser.Declaration.Declarations. */
  private Result pDeclarations$1(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    Object       yyOpValue1;
    Declarations yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pConstantDecls(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final List<ConstantDecl> v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for cd.
      final List<ConstantDecl> cd = cast(yyOpValue1);

      yyOpValue1 = null;

      yyResult = pTypeDecls(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final List<TypeDecl> v$el$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$2;
      }
      { // Start scope for td.
        final List<TypeDecl> td = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pVarDecls(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final List<VarDecl> v$el$3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$3;
        }
        { // Start scope for vd.
          final List<VarDecl> vd = cast(yyOpValue1);

          yyResult = pDeclarations$$Star1(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Pair<ProcedureDecl> pds = yyResult.semanticValue();

            yyValue = new Declarations( cd, td, vd, pds.list());

            if (yyValue instanceof Locatable) {
              setLocation((Locatable)yyValue, yyStart);
            }
            return yyResult.createValue(yyValue, yyError);
          }
        } // End scope for vd.
      } // End scope for td.
    } // End scope for cd.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Oberon.Declarations$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarations$$Star1(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fDeclarations$$Star1) 
      yyColumn.chunk2.fDeclarations$$Star1 = pDeclarations$$Star1$1(yyStart);
    return yyColumn.chunk2.fDeclarations$$Star1;
  }

  /** Actually parse eu.wietsevenema.lang.oberon.parser.Oberon.Declarations$$Star1. */
  private Result pDeclarations$$Star1$1(final int yyStart) 
    throws IOException {

    Result              yyResult;
    int                 yyBase;
    Pair<ProcedureDecl> yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pProcedureDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final ProcedureDecl v$el$4 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
      if (yyResult.hasValue(";")) {

        yyResult = pDeclarations$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<ProcedureDecl> v$5 = yyResult.semanticValue();

          yyValue = new Pair<ProcedureDecl>(v$el$4, v$5);

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal eu.wietsevenema.lang.oberon.parser.Declaration.Type.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fType) 
      yyColumn.chunk2.fType = pType$1(yyStart);
    return yyColumn.chunk2.fType;
  }

  /** Actually parse eu.wietsevenema.lang.oberon.parser.Declaration.Type. */
  private Result pType$1(final int yyStart) throws IOException {
    Result     yyResult;
    VarType    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("BOOLEAN")) {

      yyValue = new BooleanType();

      if (yyValue instanceof Locatable) {
        setLocation((Locatable)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("INTEGER")) {

      yyValue = new IntegerType();

      if (yyValue instanceof Locatable) {
        setLocation((Locatable)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pArrayType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pRecordType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Identifier id = yyResult.semanticValue();

      yyValue = new TypeAlias(id);

      if (yyValue instanceof Locatable) {
        setLocation((Locatable)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Declaration.ArrayType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArrayType(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    VarType    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("ARRAY")) {

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression exp = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pWord(yyBase);
        if (yyResult.hasValue("OF")) {

          yyResult = pType(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final VarType type = yyResult.semanticValue();

            yyValue = new ArrayType( exp, type);

            if (yyValue instanceof Locatable) {
              setLocation((Locatable)yyValue, yyStart);
            }
            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("'OF' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("array type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Declaration.RecordType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRecordType(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    VarType    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("RECORD")) {

      yyResult = pFieldList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node fl = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = 
            peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
          if (yyResult.hasValue(";")) {

            yyResult = pFieldList(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
          break;
        }
        { // Start scope for fls.
          final Pair<Node> fls = yyRepValue1.reverse();

          yyBase   = yyRepetition1;
          yyResult = pWord(yyBase);
          if (yyResult.hasValue("END")) {

            yyValue = new RecordType( new Pair<Node>(fl, fls).list() );

            if (yyValue instanceof Locatable) {
              setLocation((Locatable)yyValue, yyStart);
            }
            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("'END' expected", yyBase);
          }
        } // End scope for fls.
      }
    }

    // Done.
    yyError = yyError.select("record type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Declaration.FieldList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFieldList(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fFieldList) 
      yyColumn.chunk2.fFieldList = pFieldList$1(yyStart);
    return yyColumn.chunk2.fFieldList;
  }

  /** Actually parse eu.wietsevenema.lang.oberon.parser.Declaration.FieldList. */
  private Result pFieldList$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentList(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final List<Identifier> ids = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
      if (yyResult.hasValue(":")) {

        yyResult = pType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final VarType type = yyResult.semanticValue();

          yyValue = GNode.create("FieldList", ids, type);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Declaration.ConstantDecls.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConstantDecls(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    boolean            yyRepeated1;
    Pair<ConstantDecl> yyRepValue1;
    List<ConstantDecl> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("CONST")) {

      yyRepetition1 = yyResult.index;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pConstantDecl(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final ConstantDecl v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<ConstantDecl>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }

      if (yyRepeated1) {
        final Pair<ConstantDecl> cds = yyRepValue1.reverse();

        yyValue = new ArrayList<ConstantDecl>(cds.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("constant decls expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Declaration.ConstantDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConstantDecl(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyBase;
    ConstantDecl yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Identifier id = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
      if (yyResult.hasValue("=")) {

        yyResult = pExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expression exp = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = 
            peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
          if (yyResult.hasValue(";")) {

            yyValue = new ConstantDecl(id, exp);

            if (yyValue instanceof Locatable) {
              setLocation((Locatable)yyValue, yyStart);
            }
            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'=' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Declaration.TypeDecls.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeDecls(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyRepetition1;
    boolean        yyRepeated1;
    Pair<TypeDecl> yyRepValue1;
    List<TypeDecl> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("TYPE")) {

      yyRepetition1 = yyResult.index;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pTypeDecl(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final TypeDecl v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<TypeDecl>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }

      if (yyRepeated1) {
        final Pair<TypeDecl> tds = yyRepValue1.reverse();

        yyValue = new ArrayList<TypeDecl>(tds.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("type decls expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Declaration.TypeDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeDecl(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    TypeDecl   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Identifier id = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
      if (yyResult.hasValue("=")) {

        yyResult = pType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final VarType type = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = 
            peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
          if (yyResult.hasValue(";")) {

            yyValue = new TypeDecl(id, type);

            if (yyValue instanceof Locatable) {
              setLocation((Locatable)yyValue, yyStart);
            }
            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'=' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Declaration.VarDecls.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVarDecls(final int yyStart) throws IOException {
    Result        yyResult;
    int           yyRepetition1;
    boolean       yyRepeated1;
    Pair<VarDecl> yyRepValue1;
    List<VarDecl> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("VAR")) {

      yyRepetition1 = yyResult.index;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pVarDecl(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final VarDecl v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<VarDecl>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }

      if (yyRepeated1) {
        final Pair<VarDecl> vds = yyRepValue1.reverse();

        yyValue = new ArrayList<VarDecl>(vds.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("var decls expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal eu.wietsevenema.lang.oberon.parser.Declaration.VarDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVarDecl(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    VarDecl    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentList(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final List<Identifier> ids = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
      if (yyResult.hasValue(":")) {

        yyResult = pType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final VarType type = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = 
            peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
          if (yyResult.hasValue(";")) {

            yyValue = new VarDecl(ids, type);

            if (yyValue instanceof Locatable) {
              setLocation((Locatable)yyValue, yyStart);
            }
            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Declaration.FPSection.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFPSection(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fFPSection) 
      yyColumn.chunk3.fFPSection = pFPSection$1(yyStart);
    return yyColumn.chunk3.fFPSection;
  }

  /** Actually parse eu.wietsevenema.lang.oberon.parser.Declaration.FPSection. */
  private Result pFPSection$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    String     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyBase   = yyOption1;
    yyResult = pWord(yyBase);
    if (yyResult.hasValue("VAR")) {
      final String v$el$1 = "VAR";

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    } else {
      yyError = yyError.select("'VAR' expected", yyBase);
    }
    { // Start scope for v$g$1.
      final String v$g$1 = yyOpValue1;

      yyResult = pIdentList(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final List<Identifier> v$g$2 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
        if (yyResult.hasValue(":")) {

          yyResult = pType(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final VarType v$g$3 = yyResult.semanticValue();

            yyValue = GNode.create("FPSection", v$g$1, v$g$2, v$g$3);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("':' expected", yyBase);
        }
      }
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Declaration.FormalParameters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFormalParameters(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    List<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFPSection(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node fp = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
        if (yyResult.hasValue(";")) {

          yyResult = pFPSection(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
        break;
      }
      { // Start scope for fps.
        final Pair<Node> fps = yyRepValue1.reverse();

        yyValue = new Pair<Node>(fp, fps).list();

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for fps.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * eu.wietsevenema.lang.oberon.parser.Declaration.ProcedureDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pProcedureDecl(final int yyStart) throws IOException {
    Result        yyResult;
    int           yyBase;
    int           yyOption1;
    Object        yyOpValue1;
    int           yyOption2;
    List<Node>    yyOpValue2;
    ProcedureDecl yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("PROCEDURE")) {

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Identifier idstart = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyBase   = yyOption1;
        yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
        if (yyResult.hasValue("(")) {

          yyOption2  = yyResult.index;
          yyOpValue2 = null;

          yyResult = pFormalParameters(yyOption2);
          yyError  = yyResult.select(yyError, yyOption2);
          if (yyResult.hasValue()) {
            final List<Node> v$el$2 = yyResult.semanticValue();

            yyOption2  = yyResult.index;
            yyOpValue2 = v$el$2;
          }
          { // Start scope for v$el$1.
            final List<Node> v$el$1 = yyOpValue2;

            yyBase   = yyOption2;
            yyResult = 
              peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
            if (yyResult.hasValue(")")) {

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            } else {
              yyError = yyError.select("')' expected", yyBase);
            }
          } // End scope for v$el$1.
        } else {
          yyError = yyError.select("'(' expected", yyBase);
        }
        { // Start scope for formals.
          final List<Node> formals = cast(yyOpValue1);

          yyBase   = yyOption1;
          yyResult = 
            peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
          if (yyResult.hasValue(";")) {

            yyResult = pDeclarations(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Declarations decls = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyBase   = yyOption1;
              yyResult = pWord(yyBase);
              if (yyResult.hasValue("BEGIN")) {

                yyResult = pStatementSequence(yyResult.index);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {
                  final List<Statement> v$el$3 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$3;
                }
              } else {
                yyError = yyError.select("'BEGIN' expected", yyBase);
              }
              { // Start scope for stats.
                final List<Statement> stats = cast(yyOpValue1);

                yyBase   = yyOption1;
                yyResult = pWord(yyBase);
                if (yyResult.hasValue("END")) {

                  yyResult = pIdentifier(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyValue = new ProcedureDecl(idstart, formals, decls, stats);

                    if (yyValue instanceof Locatable) {
                      setLocation((Locatable)yyValue, yyStart);
                    }
                    return yyResult.createValue(yyValue, yyError);
                  }
                } else {
                  yyError = yyError.select("'END' expected", yyBase);
                }
              } // End scope for stats.
            }
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        } // End scope for formals.
      }
    }

    // Done.
    yyError = yyError.select("procedure decl expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal eu.wietsevenema.lang.oberon.parser.Declaration.Module.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pModule(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyBase;
    int             yyOption1;
    List<Statement> yyOpValue1;
    Module          yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("MODULE")) {

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Identifier idstart = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
        if (yyResult.hasValue(";")) {

          yyResult = pDeclarations(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Declarations decls = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyBase   = yyOption1;
            yyResult = pWord(yyBase);
            if (yyResult.hasValue("BEGIN")) {

              yyResult = pStatementSequence(yyResult.index);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {
                final List<Statement> v$el$1 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$1;
              }
            } else {
              yyError = yyError.select("'BEGIN' expected", yyBase);
            }
            { // Start scope for stats.
              final List<Statement> stats = yyOpValue1;

              yyBase   = yyOption1;
              yyResult = pWord(yyBase);
              if (yyResult.hasValue("END")) {

                yyResult = pIdentifier(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyBase   = yyResult.index;
                  yyResult = 
                    peu$wietsevenema$lang$oberon$parser$Symbol$Symbol(yyBase);
                  if (yyResult.hasValue(".")) {

                    yyValue = new Module(idstart, decls, stats );

                    if (yyValue instanceof Locatable) {
                      setLocation((Locatable)yyValue, yyStart);
                    }
                    return yyResult.createValue(yyValue, yyError);
                  } else {
                    yyError = yyError.select("'.' expected", yyBase);
                  }
                }
              } else {
                yyError = yyError.select("'END' expected", yyBase);
              }
            } // End scope for stats.
          }
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("module expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.util.Symbol.Symbol.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pxtc$util$Symbol$Symbol(final int yyStart) 
    throws IOException {

    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pxtc$util$Symbol$SymbolCharacters(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.util.Symbol.SymbolCharacters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pxtc$util$Symbol$SymbolCharacters(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '>':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '>':
              {
                final int yyChoice2 = yyIndex;

                // Nested alternative 1.

                yyC = character(yyChoice2);
                if (-1 != yyC) {
                  yyIndex = yyChoice2 + 1;
                  if ('=' == yyC) {

                    yyValue = ">>=";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }

                // Nested alternative 2.

                yyValue = ">>";

                return new SemanticValue(yyValue, yyChoice2, yyError);
              }

            case '=':
              {
                yyValue = ">=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = ">";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '<':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '<':
              {
                final int yyChoice2 = yyIndex;

                // Nested alternative 1.

                yyC = character(yyChoice2);
                if (-1 != yyC) {
                  yyIndex = yyChoice2 + 1;
                  if ('=' == yyC) {

                    yyValue = "<<=";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }

                // Nested alternative 2.

                yyValue = "<<";

                return new SemanticValue(yyValue, yyChoice2, yyError);
              }

            case '=':
              {
                yyValue = "<=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = "<";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '+':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '=':
              {
                yyValue = "+=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '+':
              {
                yyValue = "++";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = "+";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '-':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '=':
              {
                yyValue = "-=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '-':
              {
                yyValue = "--";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = "-";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '*':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "*=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "*";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '/':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "/=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "/";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '%':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "%=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "%";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '&':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '=':
              {
                yyValue = "&=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '&':
              {
                yyValue = "&&";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = "&";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '^':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "^=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "^";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '|':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '=':
              {
                yyValue = "|=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '|':
              {
                yyValue = "||";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = "|";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '=':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "==";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "=";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '!':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "!=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "!";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case ';':
        {
          yyValue = ";";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ':':
        {
          yyValue = ":";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ',':
        {
          yyValue = ",";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '.':
        {
          yyValue = ".";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '{':
        {
          yyValue = "{";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '}':
        {
          yyValue = "}";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '(':
        {
          yyValue = "(";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ')':
        {
          yyValue = ")";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '[':
        {
          yyValue = "[";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ']':
        {
          yyValue = "]";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '~':
        {
          yyValue = "~";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '?':
        {
          yyValue = "?";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("symbol characters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.util.Spacing.Spacing.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpacing(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyRepetition1;
    int        yyRepetition2;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case ' ':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\t':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\f':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\r':
          {
            final int yyChoice2 = yyIndex;

            // Nested alternative 1.

            yyC = character(yyChoice2);
            if ('\n' == yyC) {
              yyIndex = yyChoice2 + 1;

              yyRepetition1 = yyIndex;
              continue;
            }

            // Nested alternative 2.

            yyRepetition1 = yyChoice2;
            continue;
          }

        case '\n':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '/':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;

              switch (yyC) {
              case '*':
                {
                  yyRepetition2 = yyIndex;
                  while (true) {

                    final int yyChoice2 = yyRepetition2;

                    // Nested alternative 1.

                    yyC = character(yyChoice2);
                    if (-1 != yyC) {
                      yyIndex = yyChoice2 + 1;

                      switch (yyC) {
                      case '*':
                        {
                          yyPredMatched = false;

                          yyC = character(yyIndex);
                          if ('/' == yyC) {

                            yyPredMatched = true;
                          }

                          if (! yyPredMatched) {

                            yyRepetition2 = yyIndex;
                            continue;
                          } else {
                            yyError = yyError.select("spacing expected", yyStart);
                          }
                        }
                        break;

                      default:
                        {
                          yyRepetition2 = yyIndex;
                          continue;
                        }
                      }
                    }
                    break;
                  }

                  yyBase = yyRepetition2;
                  yyC    = character(yyBase);
                  if ('*' == yyC) {
                    yyIndex = yyRepetition2 + 1;

                    yyC = character(yyIndex);
                    if ('/' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyRepetition1 = yyIndex;
                      continue;
                    } else {
                      yyError = yyError.select("'*/' expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("'*/' expected", yyBase);
                  }
                }
                break;

              case '/':
                {
                  yyRepetition2 = yyIndex;
                  while (true) {

                    yyC = character(yyRepetition2);
                    if (-1 != yyC) {
                      yyIndex = yyRepetition2 + 1;

                      switch (yyC) {
                      case '\n':
                      case '\r':
                        /* No match. */
                        break;

                      default:
                        {
                          yyRepetition2 = yyIndex;
                          continue;
                        }
                      }
                    }
                    break;
                  }

                  final int yyChoice2 = yyRepetition2;

                  // Nested alternative 1.

                  yyC = character(yyChoice2);
                  if (-1 != yyC) {
                    yyIndex = yyChoice2 + 1;

                    switch (yyC) {
                    case '\r':
                      {
                        final int yyChoice3 = yyIndex;

                        // Nested alternative 1.

                        yyC = character(yyChoice3);
                        if ('\n' == yyC) {
                          yyIndex = yyChoice3 + 1;

                          yyRepetition1 = yyIndex;
                          continue;
                        }

                        // Nested alternative 2.

                        yyRepetition1 = yyChoice3;
                        continue;
                      }

                    case '\n':
                      {
                        yyRepetition1 = yyIndex;
                        continue;
                      }

                    default:
                      /* No match. */
                    }
                  }

                  // Nested alternative 2.

                  yyPredResult = pEndOfFile(yyChoice2);
                  yyError      = yyPredResult.select(yyError);
                  if (yyPredResult.hasValue()) {

                    yyRepetition1 = yyChoice2;
                    continue;
                  }
                }
                break;

              default:
                /* No match. */
              }
            }
          }
          break;

        default:
          /* No match. */
        }
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.util.Spacing.EndOfFile.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEndOfFile(final int yyStart) throws IOException {
    int        yyC;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if (-1 != yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyValue = null;

      return new SemanticValue(yyValue, yyStart, yyError);
    } else {
      yyError = yyError.select("end of file expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Get the specified text.
   *
   * @param s The text.
   * @return The text.
   */
  protected static final String toText(String s) {
    return s;
  }

  // =========================================================================

  /**
   * Parse the specified files.
   *
   * @param args The file names.
   */
  public static void main(String[] args) {
    if ((null == args) || (0 == args.length)) {
      System.err.println("Usage: <file-name>+");

    } else {
      for (int i=0; i<args.length; i++) {
        System.err.println("Processing " + args[i] + " ...");

        Reader   in = null;
        try {
          in        = new BufferedReader(new FileReader(args[i]));
          Oberon p  = 
            new Oberon(in, args[i], (int)new File(args[i]).length());
          Result r  = p.pProgram(0);

          if (r.hasValue()) {
            SemanticValue v = (SemanticValue)r;

            if (v.value instanceof Node) {
              Printer ptr = new
                Printer(new BufferedWriter(new OutputStreamWriter(System.out)));
              ptr.format((Node)v.value).pln().flush();
            } else {
              System.out.println(v.value.toString());
            }

          } else {
            ParseError err = (ParseError)r;
            if (-1 == err.index) {
              System.err.println("  Parse error");
            } else {
              System.err.println("  " + p.location(err.index) + ": " + err.msg);
            }
          }

        } catch (Throwable x) {
          while (null != x.getCause()) {
            x = x.getCause();
          }
          x.printStackTrace();
        } finally {
          try {
            in.close();
          } catch (Throwable x) {
            /* Ignore. */
          }
        }
      }
    }
  }

}
