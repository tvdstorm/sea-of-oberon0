// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 1.14.4,
// (C) 2004-2009 Robert Grimm,
// on Monday, February 7, 2011 at 11:31:38 AM.
// Edit at your own risk.
// ===========================================================================

package jdm.oberon0.parser;

import java.io.Reader;
import java.io.IOException;

import java.util.HashSet;
import java.util.Set;

import xtc.util.Pair;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

import xtc.util.Action;
import java.util.*;
import jdm.oberon0.ast.*;
import jdm.oberon0.ast.statements.*;
import jdm.oberon0.ast.expressions.*;
import jdm.oberon0.ast.types.*;
import jdm.oberon0.ast.declarations.*;

/**
 * Packrat parser for grammar <code>Oberon</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 1.14.4, (C) 2004-2009 Robert Grimm.
 */
public final class OberonParser extends ParserBase {

  /** The KEYWORDS set. */
  public static final Set<String> KEYWORDS = new HashSet<String>();

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result fIdent;
    Result fIdentifierSelector;
    Result fIdentifierSelector$$Star1;
    Result fFactor;
    Result fTerm;
    Result fTerm$$Star1;
    Result fPosNegTerm;
    Result fSimpleExpression;
    Result fSimpleExpression$$Star1;
    Result fExpression;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fFieldList;
    Result fType;
    Result fIdentList;
    Result fIdentList$$Star1;
    Result fDeclarations;
    Result fDeclarations$$Star1;
    Result fDeclarations$$Star2;
    Result fDeclarations$$Star3;
    Result fDeclarations$$Star4;
    Result fFPSection;
  }

  /** Chunk 3 of memoized results. */
  static final class Chunk3 {
    Result fElseTail;
    Result fStatement;
    Result fStatementSequence;
    Result fStatementSequence$$Star1;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class OberonParserColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
    Chunk3 chunk3;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public OberonParser(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public OberonParser(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new OberonParserColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Space.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpace(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case ' ':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\t':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\f':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\n':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\r':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("space expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Spacing.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpacing(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pSpace(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.EndOfFile.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEndOfFile(final int yyStart) throws IOException {
    int        yyC;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if (-1 != yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyValue = null;

      return new SemanticValue(yyValue, yyStart, yyError);
    } else {
      yyError = yyError.select("end of file expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Word.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWord(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyRepetition1 = yyIndex;
        while (true) {

          final int yyChoice1 = yyRepetition1;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ((('A' <= yyC) && (yyC <= 'Z')) ||
                (('a' <= yyC) && (yyC <= 'z'))) {

              yyRepetition1 = yyIndex;
              continue;
            }
          }

          // Nested alternative 2.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
              {
                yyRepetition1 = yyIndex;
                continue;
              }

            default:
              /* No match. */
            }
          }
          break;
        }

        yyValue = difference(yyStart, yyRepetition1);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("word expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Ident.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdent(final int yyStart) throws IOException {
    OberonParserColumn yyColumn = (OberonParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fIdent) 
      yyColumn.chunk1.fIdent = pIdent$1(yyStart);
    return yyColumn.chunk1.fIdent;
  }

  /** Actually parse Oberon.Ident. */
  private Result pIdent$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (!contains(KEYWORDS, yyValue)) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("ident expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.IntString.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntString(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("int string expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Integer.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInteger(final int yyStart) throws IOException {
    Result         yyResult;
    IntegerLiteral yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIntString(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String i = yyResult.semanticValue();

      yyValue = new IntegerLiteral(new Integer(i));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Identifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentifier(final int yyStart) throws IOException {
    Result     yyResult;
    Identifier yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String ident = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = new Identifier(ident);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.SelectorTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSelectorTail(final int yyStart) throws IOException {
    int                yyC;
    int                yyIndex;
    Result             yyResult;
    int                yyBase;
    Action<Expression> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '[':
        {
          yyResult = pSpacing(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Expression expr = yyResult.semanticValue();

              yyResult = pSpacing(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyBase = yyResult.index;
                yyC    = character(yyBase);
                if (']' == yyC) {
                  yyIndex = yyResult.index + 1;

                  yyValue = new Action<Expression>() {
                    public Expression run(Expression base) {
                      return new ArraySelector(base, expr);
                  }};

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("']' expected", yyBase);
                }
              }
            }
          }
        }
        break;

      case '.':
        {
          yyResult = pSpacing(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pIdent(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final String expr = yyResult.semanticValue();

              yyResult = pSpacing(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = new Action<Expression>() {
                  public Expression run(Expression base) {
                    return new RecordSelector(base, expr);
                }};

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("selector tail expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.IdentifierSelector.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentifierSelector(final int yyStart) throws IOException {
    OberonParserColumn yyColumn = (OberonParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fIdentifierSelector) 
      yyColumn.chunk1.fIdentifierSelector = pIdentifierSelector$1(yyStart);
    return yyColumn.chunk1.fIdentifierSelector;
  }

  /** Actually parse Oberon.IdentifierSelector. */
  private Result pIdentifierSelector$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Identifier seed = yyResult.semanticValue();

      yyResult = pIdentifierSelector$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expression>> actions = yyResult.semanticValue();

        yyValue = apply(actions, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.IdentifierSelector$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentifierSelector$$Star1(final int yyStart) 
    throws IOException {

    OberonParserColumn yyColumn = (OberonParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fIdentifierSelector$$Star1) 
      yyColumn.chunk1.fIdentifierSelector$$Star1 = pIdentifierSelector$$Star1$1(yyStart);
    return yyColumn.chunk1.fIdentifierSelector$$Star1;
  }

  /** Actually parse Oberon.IdentifierSelector$$Star1. */
  private Result pIdentifierSelector$$Star1$1(final int yyStart) 
    throws IOException {

    Result                   yyResult;
    Pair<Action<Expression>> yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSelectorTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Expression> v$el$1 = yyResult.semanticValue();

      yyResult = pIdentifierSelector$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expression>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<Expression>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Factor.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFactor(final int yyStart) throws IOException {
    OberonParserColumn yyColumn = (OberonParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fFactor) 
      yyColumn.chunk1.fFactor = pFactor$1(yyStart);
    return yyColumn.chunk1.fFactor;
  }

  /** Actually parse Oberon.Factor. */
  private Result pFactor$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifierSelector(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpacing(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pSpacing(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyBase = yyResult.index;
            yyC    = character(yyBase);
            if (')' == yyC) {
              yyIndex = yyResult.index + 1;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("')' expected", yyBase);
            }
          }
        }
      }
    }

    // Alternative 3.

    yyResult = pInteger(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyC = character(yyStart);
    if ('~' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpacing(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pFactor(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expression f = yyResult.semanticValue();

          yyValue = new NotExpression(f);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("factor expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.FactorTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFactorTail(final int yyStart) throws IOException {
    Result             yyResult;
    Action<Expression> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pFactorTail$$Choice1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String op = yyResult.semanticValue();

        yyResult = pSpacing(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pFactor(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Expression rhs = yyResult.semanticValue();

            yyValue = new Action<Expression>() {
              public Expression run(Expression lhs) {
                Expression result = null;
                if (op.equals("*")) result = new MulExpression(lhs, rhs);
                if (op.equals("DIV")) result = new DivExpression(lhs, rhs);
                if (op.equals("MOD")) result = new ModExpression(lhs, rhs);
                if (op.equals("&")) result = new AndExpression(lhs, rhs);
                assert (result != null);
                return result;
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.FactorTail$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFactorTail$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "*";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('D' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('I' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('V' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = "DIV";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('M' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('O' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('D' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = "MOD";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 4.

    yyC = character(yyStart);
    if ('&' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "&";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("factor tail expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Term.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTerm(final int yyStart) throws IOException {
    OberonParserColumn yyColumn = (OberonParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fTerm) 
      yyColumn.chunk1.fTerm = pTerm$1(yyStart);
    return yyColumn.chunk1.fTerm;
  }

  /** Actually parse Oberon.Term. */
  private Result pTerm$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFactor(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression seed = yyResult.semanticValue();

      yyResult = pTerm$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expression>> actions = yyResult.semanticValue();

        yyValue = apply(actions, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.Term$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTerm$$Star1(final int yyStart) throws IOException {
    OberonParserColumn yyColumn = (OberonParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fTerm$$Star1) 
      yyColumn.chunk1.fTerm$$Star1 = pTerm$$Star1$1(yyStart);
    return yyColumn.chunk1.fTerm$$Star1;
  }

  /** Actually parse Oberon.Term$$Star1. */
  private Result pTerm$$Star1$1(final int yyStart) throws IOException {
    Result                   yyResult;
    Pair<Action<Expression>> yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFactorTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Expression> v$el$1 = yyResult.semanticValue();

      yyResult = pTerm$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expression>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<Expression>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.SimpleExpressionTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleExpressionTail(final int yyStart) throws IOException {
    Result             yyResult;
    Action<Expression> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pSimpleExpressionTail$$Choice1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String op = yyResult.semanticValue();

        yyResult = pSpacing(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pTerm(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Expression rhs = yyResult.semanticValue();

            yyValue = new Action<Expression>() {
              public Expression run(Expression lhs) {
                Expression result = null;
                if (op.equals("+")) result = new AddExpression(lhs, rhs);
                if (op.equals("-")) result = new SubExpression(lhs, rhs);
                if (op.equals("OR")) result = new OrExpression(lhs, rhs);
                assert (result != null);
                return result;
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.SimpleExpressionTail$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleExpressionTail$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('+' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "+";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "-";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('O' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('R' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "OR";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("simple expression tail expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.PosNegTerm.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPosNegTerm(final int yyStart) throws IOException {
    OberonParserColumn yyColumn = (OberonParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fPosNegTerm) 
      yyColumn.chunk1.fPosNegTerm = pPosNegTerm$1(yyStart);
    return yyColumn.chunk1.fPosNegTerm;
  }

  /** Actually parse Oberon.PosNegTerm. */
  private Result pPosNegTerm$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '+':
        {
          yyResult = pSpacing(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pTerm(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expression t = yyResult.semanticValue();

              yyValue = new PosExpression(t);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
        break;

      case '-':
        {
          yyResult = pSpacing(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pTerm(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expression t = yyResult.semanticValue();

              yyValue = new NegExpression(t);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyResult = pTerm(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("pos neg term expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.SimpleExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleExpression(final int yyStart) throws IOException {
    OberonParserColumn yyColumn = (OberonParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fSimpleExpression) 
      yyColumn.chunk1.fSimpleExpression = pSimpleExpression$1(yyStart);
    return yyColumn.chunk1.fSimpleExpression;
  }

  /** Actually parse Oberon.SimpleExpression. */
  private Result pSimpleExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPosNegTerm(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression seed = yyResult.semanticValue();

      yyResult = pSimpleExpression$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expression>> actions = yyResult.semanticValue();

        yyValue = apply(actions, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pPosNegTerm(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.SimpleExpression$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleExpression$$Star1(final int yyStart) 
    throws IOException {

    OberonParserColumn yyColumn = (OberonParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fSimpleExpression$$Star1) 
      yyColumn.chunk1.fSimpleExpression$$Star1 = pSimpleExpression$$Star1$1(yyStart);
    return yyColumn.chunk1.fSimpleExpression$$Star1;
  }

  /** Actually parse Oberon.SimpleExpression$$Star1. */
  private Result pSimpleExpression$$Star1$1(final int yyStart) 
    throws IOException {

    Result                   yyResult;
    Pair<Action<Expression>> yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSimpleExpressionTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Expression> v$el$2 = yyResult.semanticValue();

      yyResult = pSimpleExpression$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expression>> v$3 = yyResult.semanticValue();

        yyValue = new Pair<Action<Expression>>(v$el$2, v$3);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Expression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression(final int yyStart) throws IOException {
    OberonParserColumn yyColumn = (OberonParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExpression) 
      yyColumn.chunk1.fExpression = pExpression$1(yyStart);
    return yyColumn.chunk1.fExpression;
  }

  /** Actually parse Oberon.Expression. */
  private Result pExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pSimpleExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expression lhs = yyResult.semanticValue();

        yyResult = pSpacing(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExpression$$Choice1(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String op = yyResult.semanticValue();

            yyResult = pSpacing(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pSimpleExpression(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expression rhs = yyResult.semanticValue();

                yyResult = pSpacing(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = null;
                  if ("=".equals(op)) yyValue = new EqExpression(lhs, rhs);
                  if ("#".equals(op)) yyValue = new NeExpression(lhs, rhs);
                  if ("<".equals(op)) yyValue = new LtExpression(lhs, rhs);
                  if (">".equals(op)) yyValue = new GtExpression(lhs, rhs);
                  if ("<=".equals(op)) yyValue = new LeExpression(lhs, rhs);
                  if (">=".equals(op)) yyValue = new GeExpression(lhs, rhs);
                  assert (yyValue != null);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pSimpleExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.Expression$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "=";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('#' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "#";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "<=";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 4.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = ">=";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 5.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "<";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 6.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = ">";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Assignment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssignment(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Statement  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifierSelector(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression lhs = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if (':' == yyC) {
          yyIndex = yyResult.index + 1;

          yyC = character(yyIndex);
          if ('=' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = pSpacing(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pExpression(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expression rhs = yyResult.semanticValue();

                yyValue = new Assignment(lhs, rhs);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } else {
            yyError = yyError.select("':=' expected", yyBase);
          }
        } else {
          yyError = yyError.select("':=' expected", yyBase);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.IdentifierType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentifierType(final int yyStart) throws IOException {
    Result         yyResult;
    IdentifierType yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String ident = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = new IdentifierType(ident);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.ArrayType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArrayType(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    ArrayType  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('A' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('R' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('R' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('A' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('Y' == yyC) {
              yyIndex = yyIndex + 1;

              yyResult = pSpacing(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pExpression(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Expression length = yyResult.semanticValue();

                  yyResult = pSpacing(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyBase = yyResult.index;
                    yyC    = character(yyBase);
                    if ('O' == yyC) {
                      yyIndex = yyResult.index + 1;

                      yyC = character(yyIndex);
                      if ('F' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyResult = pSpacing(yyIndex);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pType(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {
                            Type type = yyResult.semanticValue();

                            yyValue = new ArrayType(length, type);

                            return yyResult.createValue(yyValue, yyError);
                          }
                        }
                      } else {
                        yyError = yyError.select("'OF' expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("'OF' expected", yyBase);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("array type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.FieldList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFieldList(final int yyStart) throws IOException {
    OberonParserColumn yyColumn = (OberonParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fFieldList) 
      yyColumn.chunk2.fFieldList = pFieldList$1(yyStart);
    return yyColumn.chunk2.fFieldList;
  }

  /** Actually parse Oberon.FieldList. */
  private Result pFieldList$1(final int yyStart) throws IOException {
    int                  yyC;
    int                  yyIndex;
    Result               yyResult;
    int                  yyBase;
    HashMap<String,Type> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentList(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<String> idents = yyResult.semanticValue();

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if (':' == yyC) {
        yyIndex = yyResult.index + 1;

        yyResult = pSpacing(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pType(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Type t = yyResult.semanticValue();

            yyResult = pSpacing(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = new HashMap<String, Type>();
              for(String s : idents) {
                yyValue.put(s, t);
              }

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.RecordType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRecordType(final int yyStart) throws IOException {
    int                        yyC;
    int                        yyIndex;
    Result                     yyResult;
    int                        yyBase;
    int                        yyRepetition1;
    Pair<HashMap<String,Type>> yyRepValue1;
    RecordType                 yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('R' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('E' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('C' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('O' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('R' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('D' == yyC) {
                yyIndex = yyIndex + 1;

                yyResult = pSpacing(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pFieldList(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    HashMap<String,Type> l1 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepValue1   = Pair.empty();
                    while (true) {

                      yyBase = yyRepetition1;
                      yyC    = character(yyBase);
                      if (';' == yyC) {
                        yyIndex = yyRepetition1 + 1;

                        yyResult = pSpacing(yyIndex);
                        yyError  = yyResult.select(yyError, yyRepetition1);
                        if (yyResult.hasValue()) {

                          yyResult = pFieldList(yyResult.index);
                          yyError  = yyResult.select(yyError, yyRepetition1);
                          if (yyResult.hasValue()) {
                            HashMap<String,Type> v$el$1 = yyResult.semanticValue();

                            yyRepetition1 = yyResult.index;
                            yyRepValue1   = 
                              new Pair<HashMap<String,Type>>(v$el$1, yyRepValue1);
                            continue;
                          }
                        }
                      } else {
                        yyError = yyError.select("';' expected", yyBase);
                      }
                      break;
                    }
                    { // Start scope for l2.
                      Pair<HashMap<String,Type>> l2 = yyRepValue1.reverse();

                      yyResult = pSpacing(yyRepetition1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyBase = yyResult.index;
                        yyC    = character(yyBase);
                        if ('E' == yyC) {
                          yyIndex = yyResult.index + 1;

                          yyC = character(yyIndex);
                          if ('N' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('D' == yyC) {
                              yyIndex = yyIndex + 1;

                              yyResult = pSpacing(yyIndex);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                for(HashMap<String, Type> map : l2.list()) {
                                  l1.putAll(map);
                                }
                                yyValue = new RecordType(l1);

                                return yyResult.createValue(yyValue, yyError);
                              }
                            } else {
                              yyError = yyError.select("'END' expected", yyBase);
                            }
                          } else {
                            yyError = yyError.select("'END' expected", yyBase);
                          }
                        } else {
                          yyError = yyError.select("'END' expected", yyBase);
                        }
                      }
                    } // End scope for l2.
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("record type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Type.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType(final int yyStart) throws IOException {
    OberonParserColumn yyColumn = (OberonParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fType) 
      yyColumn.chunk2.fType = pType$1(yyStart);
    return yyColumn.chunk2.fType;
  }

  /** Actually parse Oberon.Type. */
  private Result pType$1(final int yyStart) throws IOException {
    Result     yyResult;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pArrayType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pRecordType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pIdentifierType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.IdentList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentList(final int yyStart) throws IOException {
    OberonParserColumn yyColumn = (OberonParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fIdentList) 
      yyColumn.chunk2.fIdentList = pIdentList$1(yyStart);
    return yyColumn.chunk2.fIdentList;
  }

  /** Actually parse Oberon.IdentList. */
  private Result pIdentList$1(final int yyStart) throws IOException {
    Result       yyResult;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String ident1 = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdentList$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<String> ident2 = yyResult.semanticValue();

          yyValue = new Pair<String>(ident1, ident2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.IdentList$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentList$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpacing(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdent(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pSpacing(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("ident list expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.IdentList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentList$$Star1(final int yyStart) throws IOException {
    OberonParserColumn yyColumn = (OberonParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fIdentList$$Star1) 
      yyColumn.chunk2.fIdentList$$Star1 = pIdentList$$Star1$1(yyStart);
    return yyColumn.chunk2.fIdentList$$Star1;
  }

  /** Actually parse Oberon.IdentList$$Star1. */
  private Result pIdentList$$Star1$1(final int yyStart) throws IOException {
    Result       yyResult;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentList$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyResult = pIdentList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<String> v$2 = yyResult.semanticValue();

        yyValue = new Pair<String>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.ConstDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConstDeclaration(final int yyStart) throws IOException {
    int              yyC;
    int              yyIndex;
    Result           yyResult;
    int              yyBase;
    ConstDeclaration yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String ident = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if ('=' == yyC) {
          yyIndex = yyResult.index + 1;

          yyResult = pSpacing(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expression expr = yyResult.semanticValue();

              yyBase = yyResult.index;
              yyC    = character(yyBase);
              if (';' == yyC) {
                yyIndex = yyResult.index + 1;

                yyResult = pSpacing(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = new ConstDeclaration(ident, expr);

                  return yyResult.createValue(yyValue, yyError);
                }
              } else {
                yyError = yyError.select("';' expected", yyBase);
              }
            }
          }
        } else {
          yyError = yyError.select("'=' expected", yyBase);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.VarDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVarDeclaration(final int yyStart) throws IOException {
    int            yyC;
    int            yyIndex;
    Result         yyResult;
    int            yyBase;
    VarDeclaration yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentList(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<String> idents = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if (':' == yyC) {
          yyIndex = yyResult.index + 1;

          yyResult = pSpacing(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pType(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type type = yyResult.semanticValue();

              yyResult = pSpacing(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyBase = yyResult.index;
                yyC    = character(yyBase);
                if (';' == yyC) {
                  yyIndex = yyResult.index + 1;

                  yyResult = pSpacing(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyValue = new VarDeclaration(idents.list(), type);

                    return yyResult.createValue(yyValue, yyError);
                  }
                } else {
                  yyError = yyError.select("';' expected", yyBase);
                }
              }
            }
          }
        } else {
          yyError = yyError.select("':' expected", yyBase);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.TypeDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeDeclaration(final int yyStart) throws IOException {
    int             yyC;
    int             yyIndex;
    Result          yyResult;
    int             yyBase;
    TypeDeclaration yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String name = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if ('=' == yyC) {
          yyIndex = yyResult.index + 1;

          yyResult = pSpacing(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pType(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type type = yyResult.semanticValue();

              yyResult = pSpacing(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyBase = yyResult.index;
                yyC    = character(yyBase);
                if (';' == yyC) {
                  yyIndex = yyResult.index + 1;

                  yyResult = pSpacing(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyValue = new TypeDeclaration(name, type);

                    return yyResult.createValue(yyValue, yyError);
                  }
                } else {
                  yyError = yyError.select("';' expected", yyBase);
                }
              }
            }
          }
        } else {
          yyError = yyError.select("'=' expected", yyBase);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Declarations.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarations(final int yyStart) throws IOException {
    OberonParserColumn yyColumn = (OberonParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fDeclarations) 
      yyColumn.chunk2.fDeclarations = pDeclarations$1(yyStart);
    return yyColumn.chunk2.fDeclarations;
  }

  /** Actually parse Oberon.Declarations. */
  private Result pDeclarations$1(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    Object       yyOpValue1;
    Declarations yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pDeclarations$$Choice1(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      Pair<ConstDeclaration> v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for consts.
      Pair<ConstDeclaration> consts = cast(yyOpValue1);

      yyOpValue1 = null;

      yyResult = pDeclarations$$Choice2(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        Pair<TypeDeclaration> v$el$4 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$4;
      }
      { // Start scope for types.
        Pair<TypeDeclaration> types = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pDeclarations$$Choice3(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          Pair<VarDeclaration> v$el$7 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$7;
        }
        { // Start scope for vars.
          Pair<VarDeclaration> vars = cast(yyOpValue1);

          yyResult = pDeclarations$$Star4(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<ProcedureDeclaration> procs = yyResult.semanticValue();

            List<Declaration> decls = new ArrayList<Declaration>();
            if (consts != null) consts.addTo(decls);
            if (types != null) types.addTo(decls);
            if (vars != null) vars.addTo(decls);
            if (procs != null) procs.addTo(decls);
            yyValue = new Declarations(decls);

            return yyResult.createValue(yyValue, yyError);
          }
        } // End scope for vars.
      } // End scope for types.
    } // End scope for consts.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.Declarations$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarations$$Star1(final int yyStart) throws IOException {
    OberonParserColumn yyColumn = (OberonParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fDeclarations$$Star1) 
      yyColumn.chunk2.fDeclarations$$Star1 = pDeclarations$$Star1$1(yyStart);
    return yyColumn.chunk2.fDeclarations$$Star1;
  }

  /** Actually parse Oberon.Declarations$$Star1. */
  private Result pDeclarations$$Star1$1(final int yyStart) 
    throws IOException {

    Result                 yyResult;
    Pair<ConstDeclaration> yyValue;
    ParseError             yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pConstDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ConstDeclaration v$el$2 = yyResult.semanticValue();

      yyResult = pDeclarations$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<ConstDeclaration> v$3 = yyResult.semanticValue();

        yyValue = new Pair<ConstDeclaration>(v$el$2, v$3);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.Declarations$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarations$$Choice1(final int yyStart) 
    throws IOException {

    int                    yyC;
    int                    yyIndex;
    Result                 yyResult;
    Pair<ConstDeclaration> yyValue;
    ParseError             yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('C' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('O' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('N' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('S' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('T' == yyC) {
              yyIndex = yyIndex + 1;

              yyResult = pSpacing(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pDeclarations$$Star1(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  yyValue = yyResult.semanticValue();

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("declarations expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.Declarations$$Star2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarations$$Star2(final int yyStart) throws IOException {
    OberonParserColumn yyColumn = (OberonParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fDeclarations$$Star2) 
      yyColumn.chunk2.fDeclarations$$Star2 = pDeclarations$$Star2$1(yyStart);
    return yyColumn.chunk2.fDeclarations$$Star2;
  }

  /** Actually parse Oberon.Declarations$$Star2. */
  private Result pDeclarations$$Star2$1(final int yyStart) 
    throws IOException {

    Result                yyResult;
    Pair<TypeDeclaration> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTypeDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TypeDeclaration v$el$5 = yyResult.semanticValue();

      yyResult = pDeclarations$$Star2(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<TypeDeclaration> v$6 = yyResult.semanticValue();

        yyValue = new Pair<TypeDeclaration>(v$el$5, v$6);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.Declarations$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarations$$Choice2(final int yyStart) 
    throws IOException {

    int                   yyC;
    int                   yyIndex;
    Result                yyResult;
    Pair<TypeDeclaration> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('T' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('Y' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('P' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('E' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = pSpacing(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pDeclarations$$Star2(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                yyValue = yyResult.semanticValue();

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("declarations expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.Declarations$$Star3.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarations$$Star3(final int yyStart) throws IOException {
    OberonParserColumn yyColumn = (OberonParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fDeclarations$$Star3) 
      yyColumn.chunk2.fDeclarations$$Star3 = pDeclarations$$Star3$1(yyStart);
    return yyColumn.chunk2.fDeclarations$$Star3;
  }

  /** Actually parse Oberon.Declarations$$Star3. */
  private Result pDeclarations$$Star3$1(final int yyStart) 
    throws IOException {

    Result               yyResult;
    Pair<VarDeclaration> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pVarDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      VarDeclaration v$el$8 = yyResult.semanticValue();

      yyResult = pDeclarations$$Star3(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<VarDeclaration> v$9 = yyResult.semanticValue();

        yyValue = new Pair<VarDeclaration>(v$el$8, v$9);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.Declarations$$Choice3.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarations$$Choice3(final int yyStart) 
    throws IOException {

    int                  yyC;
    int                  yyIndex;
    Result               yyResult;
    Pair<VarDeclaration> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('V' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('A' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('R' == yyC) {
          yyIndex = yyIndex + 1;

          yyResult = pSpacing(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pDeclarations$$Star3(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              yyValue = yyResult.semanticValue();

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("declarations expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.Declarations$$Choice4.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarations$$Choice4(final int yyStart) 
    throws IOException {

    int                  yyC;
    int                  yyIndex;
    Result               yyResult;
    int                  yyBase;
    ProcedureDeclaration yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pProcedureDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if (';' == yyC) {
        yyIndex = yyResult.index + 1;

        yyResult = pSpacing(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.Declarations$$Star4.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarations$$Star4(final int yyStart) throws IOException {
    OberonParserColumn yyColumn = (OberonParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fDeclarations$$Star4) 
      yyColumn.chunk2.fDeclarations$$Star4 = pDeclarations$$Star4$1(yyStart);
    return yyColumn.chunk2.fDeclarations$$Star4;
  }

  /** Actually parse Oberon.Declarations$$Star4. */
  private Result pDeclarations$$Star4$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    Pair<ProcedureDeclaration> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDeclarations$$Choice4(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ProcedureDeclaration v$el$10 = yyResult.semanticValue();

      yyResult = pDeclarations$$Star4(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<ProcedureDeclaration> v$11 = yyResult.semanticValue();

        yyValue = new Pair<ProcedureDeclaration>(v$el$10, v$11);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.FPSection.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFPSection(final int yyStart) throws IOException {
    OberonParserColumn yyColumn = (OberonParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fFPSection) 
      yyColumn.chunk2.fFPSection = pFPSection$1(yyStart);
    return yyColumn.chunk2.fFPSection;
  }

  /** Actually parse Oberon.FPSection. */
  private Result pFPSection$1(final int yyStart) throws IOException {
    int             yyC;
    int             yyIndex;
    Result          yyResult;
    int             yyBase;
    int             yyOption1;
    String          yyOpValue1;
    List<Parameter> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyBase = yyOption1;
    yyC    = character(yyBase);
    if ('V' == yyC) {
      yyIndex = yyOption1 + 1;

      yyC = character(yyIndex);
      if ('A' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('R' == yyC) {
          yyIndex = yyIndex + 1;
          String v$el$1 = "VAR";

          yyOption1  = yyIndex;
          yyOpValue1 = v$el$1;
        } else {
          yyError = yyError.select("'VAR' expected", yyBase);
        }
      } else {
        yyError = yyError.select("'VAR' expected", yyBase);
      }
    } else {
      yyError = yyError.select("'VAR' expected", yyBase);
    }
    { // Start scope for var.
      String var = yyOpValue1;

      yyResult = pSpacing(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdentList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<String> names = yyResult.semanticValue();

          yyResult = pSpacing(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyBase = yyResult.index;
            yyC    = character(yyBase);
            if (':' == yyC) {
              yyIndex = yyResult.index + 1;

              yyResult = pSpacing(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pType(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Type type = yyResult.semanticValue();

                  yyValue = new ArrayList<Parameter>();
                  boolean byRef = ("VAR".equals(var));
                  for(int i=0; i<names.size(); i++) {
                    yyValue.add(new Parameter(names.get(i), type, byRef));
                  }

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            } else {
              yyError = yyError.select("':' expected", yyBase);
            }
          }
        }
      }
    } // End scope for var.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.FormalParameters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFormalParameters(final int yyStart) throws IOException {
    int                   yyC;
    int                   yyIndex;
    Result                yyResult;
    int                   yyBase;
    int                   yyRepetition1;
    Pair<List<Parameter>> yyRepValue1;
    List<Parameter>       yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpacing(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyBase = yyChoice1;
        yyC    = character(yyBase);
        if (')' == yyC) {
          yyIndex = yyChoice1 + 1;
          { // Start scope for yyValue.
            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } // End scope for yyValue.
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }

        // Nested alternative 2.

        yyResult = pFPSection(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Parameter> args1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pFormalParameters$$Choice1(yyRepetition1);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              List<Parameter> v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<List<Parameter>>(v$el$1, yyRepValue1);
              continue;
            }
            break;
          }
          { // Start scope for args2.
            Pair<List<Parameter>> args2 = yyRepValue1.reverse();

            yyBase = yyRepetition1;
            yyC    = character(yyBase);
            if (')' == yyC) {
              yyIndex = yyRepetition1 + 1;

              List<Parameter> params = new ArrayList<Parameter>();
              if (args1 != null) params.addAll(args1);
              if (args2 != null) {
                for(List<Parameter> l : args2.list())
                params.addAll(l);
              }
              yyValue = params;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("')' expected", yyBase);
            }
          } // End scope for args2.
        }
      }
    }

    // Done.
    yyError = yyError.select("formal parameters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.FormalParameters$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFormalParameters$$Choice1(final int yyStart) 
    throws IOException {

    int             yyC;
    int             yyIndex;
    Result          yyResult;
    List<Parameter> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (';' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpacing(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pFPSection(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("formal parameters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.ProcedureDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pProcedureDeclaration(final int yyStart) throws IOException {
    int                  yyC;
    int                  yyIndex;
    Result               yyResult;
    int                  yyBase;
    int                  yyOption1;
    Object               yyOpValue1;
    ProcedureDeclaration yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('P' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('R' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('O' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('C' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('E' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('D' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('U' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('R' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('E' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyResult = pSpacing(yyIndex);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pIdent(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          String name = yyResult.semanticValue();

                          yyResult = pSpacing(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyOption1  = yyResult.index;
                            yyOpValue1 = null;

                            yyResult = pFormalParameters(yyOption1);
                            yyError  = yyResult.select(yyError, yyOption1);
                            if (yyResult.hasValue()) {
                              List<Parameter> v$el$1 = yyResult.semanticValue();

                              yyOption1  = yyResult.index;
                              yyOpValue1 = v$el$1;
                            }
                            { // Start scope for params.
                              List<Parameter> params = cast(yyOpValue1);

                              yyResult = pSpacing(yyOption1);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyBase = yyResult.index;
                                yyC    = character(yyBase);
                                if (';' == yyC) {
                                  yyIndex = yyResult.index + 1;

                                  yyResult = pSpacing(yyIndex);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyResult = pDeclarations(yyResult.index);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {
                                      Declarations decl = yyResult.semanticValue();

                                      yyResult = pSpacing(yyResult.index);
                                      yyError  = yyResult.select(yyError);
                                      if (yyResult.hasValue()) {

                                        yyOption1  = yyResult.index;
                                        yyOpValue1 = null;

                                        yyResult = 
                                          pProcedureDeclaration$$Choice1(yyOption1);
                                        yyError  = 
                                          yyResult.select(yyError, yyOption1);
                                        if (yyResult.hasValue()) {
                                          StatementSequence v$el$2 = yyResult.semanticValue();

                                          yyOption1  = yyResult.index;
                                          yyOpValue1 = v$el$2;
                                        }
                                        { // Start scope for stat.
                                          StatementSequence stat = cast(yyOpValue1);

                                          yyResult = pSpacing(yyOption1);
                                          yyError  = yyResult.select(yyError);
                                          if (yyResult.hasValue()) {

                                            yyBase = yyResult.index;
                                            yyC    = character(yyBase);
                                            if ('E' == yyC) {
                                              yyIndex = yyResult.index + 1;

                                              yyC = character(yyIndex);
                                              if ('N' == yyC) {
                                                yyIndex = yyIndex + 1;

                                                yyC = character(yyIndex);
                                                if ('D' == yyC) {
                                                  yyIndex = yyIndex + 1;

                                                  yyResult = 
                                                    pSpacing(yyIndex);
                                                  yyError  = 
                                                    yyResult.select(yyError);
                                                  if (yyResult.hasValue()) {

                                                    yyResult = 
                                                      pIdent(yyResult.index);
                                                    yyError  = 
                                                      yyResult.select(yyError);
                                                    if (yyResult.hasValue()) {

                                                      yyResult = 
                                                        pSpacing(yyResult.index);
                                                      yyError  = 
                                                        yyResult.select(yyError);
                                                      if (yyResult.hasValue()) {

                                                        if (params == null) params = new ArrayList<Parameter>();
                                                        yyValue = new ProcedureDeclaration(name, params, decl, stat);

                                                        return yyResult.createValue(yyValue, yyError);
                                                      }
                                                    }
                                                  }
                                                } else {
                                                  yyError = yyError.select("'END' expected", yyBase);
                                                }
                                              } else {
                                                yyError = yyError.select("'END' expected", yyBase);
                                              }
                                            } else {
                                              yyError = yyError.select("'END' expected", yyBase);
                                            }
                                          }
                                        } // End scope for stat.
                                      }
                                    }
                                  }
                                } else {
                                  yyError = yyError.select("';' expected", yyBase);
                                }
                              }
                            } // End scope for params.
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("procedure declaration expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.ProcedureDeclaration$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pProcedureDeclaration$$Choice1(final int yyStart) 
    throws IOException {

    int               yyC;
    int               yyIndex;
    Result            yyResult;
    StatementSequence yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('B' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('E' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('G' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('I' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('N' == yyC) {
              yyIndex = yyIndex + 1;

              yyResult = pSpacing(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pStatementSequence(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  yyValue = yyResult.semanticValue();

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("procedure declaration expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.ActualParameters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pActualParameters(final int yyStart) throws IOException {
    int              yyC;
    int              yyIndex;
    Result           yyResult;
    int              yyBase;
    int              yyRepetition1;
    Pair<Expression> yyRepValue1;
    Pair<Expression> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpacing(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyBase = yyChoice1;
        yyC    = character(yyBase);
        if (')' == yyC) {
          yyIndex = yyChoice1 + 1;
          { // Start scope for yyValue.
            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } // End scope for yyValue.
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }

        // Nested alternative 2.

        yyResult = pExpression(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expression expr1 = yyResult.semanticValue();

          yyResult = pSpacing(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyRepetition1 = yyResult.index;
            yyRepValue1   = Pair.empty();
            while (true) {

              yyResult = pActualParameters$$Choice1(yyRepetition1);
              yyError  = yyResult.select(yyError, yyRepetition1);
              if (yyResult.hasValue()) {
                Expression v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Expression>(v$el$1, yyRepValue1);
                continue;
              }
              break;
            }
            { // Start scope for expr2.
              Pair<Expression> expr2 = yyRepValue1.reverse();

              yyBase = yyRepetition1;
              yyC    = character(yyBase);
              if (')' == yyC) {
                yyIndex = yyRepetition1 + 1;

                yyValue = new Pair<Expression>(expr1, expr2);

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("')' expected", yyBase);
              }
            } // End scope for expr2.
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("actual parameters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.ActualParameters$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pActualParameters$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpacing(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("actual parameters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.ProcedureCall.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pProcedureCall(final int yyStart) throws IOException {
    Result           yyResult;
    int              yyOption1;
    Pair<Expression> yyOpValue1;
    ProcedureCall    yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String name = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pActualParameters(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          Pair<Expression> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for params.
          Pair<Expression> params = yyOpValue1;

          yyValue = new ProcedureCall(name, params != null ? params.list() : null);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for params.
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.ElseTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pElseTail(final int yyStart) throws IOException {
    OberonParserColumn yyColumn = (OberonParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fElseTail) 
      yyColumn.chunk3.fElseTail = pElseTail$1(yyStart);
    return yyColumn.chunk3.fElseTail;
  }

  /** Actually parse Oberon.ElseTail. */
  private Result pElseTail$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Statement  yyOpValue1;
    Statement  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ('E' == yyC) {

        yyC = character(yyIndex);
        if (-1 != yyC) {
          yyIndex = yyIndex + 1;
          if ('L' == yyC) {

            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;
              if ('S' == yyC) {

                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'E':
                    {
                      yyResult = pSpacing(yyIndex);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pStatementSequence(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          yyValue = yyResult.semanticValue();

                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    }
                    break;

                  case 'I':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('F' == yyC) {

                          yyResult = pSpacing(yyIndex);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pExpression(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {
                              Expression expr = yyResult.semanticValue();

                              yyBase = yyResult.index;
                              yyC    = character(yyBase);
                              if ('T' == yyC) {
                                yyIndex = yyResult.index + 1;

                                yyC = character(yyIndex);
                                if ('H' == yyC) {
                                  yyIndex = yyIndex + 1;

                                  yyC = character(yyIndex);
                                  if ('E' == yyC) {
                                    yyIndex = yyIndex + 1;

                                    yyC = character(yyIndex);
                                    if ('N' == yyC) {
                                      yyIndex = yyIndex + 1;

                                      yyResult = pSpacing(yyIndex);
                                      yyError  = yyResult.select(yyError);
                                      if (yyResult.hasValue()) {

                                        yyResult = 
                                          pStatementSequence(yyResult.index);
                                        yyError  = yyResult.select(yyError);
                                        if (yyResult.hasValue()) {
                                          StatementSequence stat1 = yyResult.semanticValue();

                                          yyOption1  = yyResult.index;
                                          yyOpValue1 = null;

                                          yyResult = pElseTail(yyOption1);
                                          yyError  = 
                                            yyResult.select(yyError, yyOption1);
                                          if (yyResult.hasValue()) {
                                            Statement v$el$1 = yyResult.semanticValue();

                                            yyOption1  = yyResult.index;
                                            yyOpValue1 = v$el$1;
                                          }
                                          { // Start scope for stat2.
                                            Statement stat2 = yyOpValue1;

                                            yyResult = pSpacing(yyOption1);
                                            yyError  = 
                                              yyResult.select(yyError);
                                            if (yyResult.hasValue()) {

                                              yyValue = new IfStatement(expr, stat1, stat2);

                                              return yyResult.createValue(yyValue, yyError);
                                            }
                                          } // End scope for stat2.
                                        }
                                      }
                                    } else {
                                      yyError = yyError.select("'THEN' expected", yyBase);
                                    }
                                  } else {
                                    yyError = yyError.select("'THEN' expected", yyBase);
                                  }
                                } else {
                                  yyError = yyError.select("'THEN' expected", yyBase);
                                }
                              } else {
                                yyError = yyError.select("'THEN' expected", yyBase);
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("else tail expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.IfStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pIfStatement(final int yyStart) throws IOException {
    int         yyC;
    int         yyIndex;
    Result      yyResult;
    int         yyBase;
    int         yyOption1;
    Statement   yyOpValue1;
    IfStatement yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('I' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('F' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pSpacing(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expression expr = yyResult.semanticValue();

            yyBase = yyResult.index;
            yyC    = character(yyBase);
            if ('T' == yyC) {
              yyIndex = yyResult.index + 1;

              yyC = character(yyIndex);
              if ('H' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('E' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('N' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyResult = pStatementSequence(yyIndex);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      StatementSequence stat1 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = null;

                      yyResult = pElseTail(yyOption1);
                      yyError  = yyResult.select(yyError, yyOption1);
                      if (yyResult.hasValue()) {
                        Statement v$el$1 = yyResult.semanticValue();

                        yyOption1  = yyResult.index;
                        yyOpValue1 = v$el$1;
                      }
                      { // Start scope for stat2.
                        Statement stat2 = yyOpValue1;

                        yyBase = yyOption1;
                        yyC    = character(yyBase);
                        if ('E' == yyC) {
                          yyIndex = yyOption1 + 1;

                          yyC = character(yyIndex);
                          if ('N' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('D' == yyC) {
                              yyIndex = yyIndex + 1;

                              yyResult = pSpacing(yyIndex);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyValue = new IfStatement(expr, stat1, stat2);

                                return yyResult.createValue(yyValue, yyError);
                              }
                            } else {
                              yyError = yyError.select("'END' expected", yyBase);
                            }
                          } else {
                            yyError = yyError.select("'END' expected", yyBase);
                          }
                        } else {
                          yyError = yyError.select("'END' expected", yyBase);
                        }
                      } // End scope for stat2.
                    }
                  } else {
                    yyError = yyError.select("'THEN' expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("'THEN' expected", yyBase);
                }
              } else {
                yyError = yyError.select("'THEN' expected", yyBase);
              }
            } else {
              yyError = yyError.select("'THEN' expected", yyBase);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("if statement expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.WhileStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pWhileStatement(final int yyStart) throws IOException {
    int            yyC;
    int            yyIndex;
    Result         yyResult;
    int            yyBase;
    WhileStatement yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('W' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('H' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('I' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('L' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('E' == yyC) {
              yyIndex = yyIndex + 1;

              yyResult = pSpacing(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pExpression(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Expression expr = yyResult.semanticValue();

                  yyResult = pSpacing(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyBase = yyResult.index;
                    yyC    = character(yyBase);
                    if ('D' == yyC) {
                      yyIndex = yyResult.index + 1;

                      yyC = character(yyIndex);
                      if ('O' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyResult = pStatementSequence(yyIndex);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          StatementSequence stat = yyResult.semanticValue();

                          yyBase = yyResult.index;
                          yyC    = character(yyBase);
                          if ('E' == yyC) {
                            yyIndex = yyResult.index + 1;

                            yyC = character(yyIndex);
                            if ('N' == yyC) {
                              yyIndex = yyIndex + 1;

                              yyC = character(yyIndex);
                              if ('D' == yyC) {
                                yyIndex = yyIndex + 1;

                                yyResult = pSpacing(yyIndex);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {

                                  yyValue = new WhileStatement(expr, stat);

                                  return yyResult.createValue(yyValue, yyError);
                                }
                              } else {
                                yyError = yyError.select("'END' expected", yyBase);
                              }
                            } else {
                              yyError = yyError.select("'END' expected", yyBase);
                            }
                          } else {
                            yyError = yyError.select("'END' expected", yyBase);
                          }
                        }
                      } else {
                        yyError = yyError.select("'DO' expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("'DO' expected", yyBase);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("while statement expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Statement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pStatement(final int yyStart) throws IOException {
    OberonParserColumn yyColumn = (OberonParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fStatement) 
      yyColumn.chunk3.fStatement = pStatement$1(yyStart);
    return yyColumn.chunk3.fStatement;
  }

  /** Actually parse Oberon.Statement. */
  private Result pStatement$1(final int yyStart) throws IOException {
    Result     yyResult;
    Statement  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAssignment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pIfStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pWhileStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pProcedureCall(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.StatementSequence.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStatementSequence(final int yyStart) throws IOException {
    OberonParserColumn yyColumn = (OberonParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fStatementSequence) 
      yyColumn.chunk3.fStatementSequence = pStatementSequence$1(yyStart);
    return yyColumn.chunk3.fStatementSequence;
  }

  /** Actually parse Oberon.StatementSequence. */
  private Result pStatementSequence$1(final int yyStart) throws IOException {
    Result            yyResult;
    StatementSequence yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pStatement(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Statement s1 = yyResult.semanticValue();

        yyResult = pSpacing(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pStatementSequence$$Star1(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<Statement> s2 = yyResult.semanticValue();

            yyValue = new StatementSequence((new Pair<Statement>(s1, s2)).list());

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.StatementSequence$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStatementSequence$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Statement  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (';' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpacing(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStatement(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pSpacing(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("statement sequence expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.StatementSequence$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStatementSequence$$Star1(final int yyStart) 
    throws IOException {

    OberonParserColumn yyColumn = (OberonParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fStatementSequence$$Star1) 
      yyColumn.chunk3.fStatementSequence$$Star1 = pStatementSequence$$Star1$1(yyStart);
    return yyColumn.chunk3.fStatementSequence$$Star1;
  }

  /** Actually parse Oberon.StatementSequence$$Star1. */
  private Result pStatementSequence$$Star1$1(final int yyStart) 
    throws IOException {

    Result          yyResult;
    Pair<Statement> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStatementSequence$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Statement v$el$1 = yyResult.semanticValue();

      yyResult = pStatementSequence$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Statement> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Statement>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Module.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pModule(final int yyStart) throws IOException {
    int               yyC;
    int               yyIndex;
    Result            yyResult;
    int               yyBase;
    int               yyOption1;
    StatementSequence yyOpValue1;
    Module            yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('M' == yyC) {
        yyIndex = yyResult.index + 1;

        yyC = character(yyIndex);
        if ('O' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('D' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('U' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('L' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('E' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyResult = pSpacing(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pIdent(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      String ident = yyResult.semanticValue();

                      yyResult = pSpacing(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyBase = yyResult.index;
                        yyC    = character(yyBase);
                        if (';' == yyC) {
                          yyIndex = yyResult.index + 1;

                          yyResult = pSpacing(yyIndex);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pDeclarations(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {
                              Declarations decl = yyResult.semanticValue();

                              yyOption1  = yyResult.index;
                              yyOpValue1 = null;

                              yyResult = pModule$$Choice1(yyOption1);
                              yyError  = yyResult.select(yyError, yyOption1);
                              if (yyResult.hasValue()) {
                                StatementSequence v$el$1 = yyResult.semanticValue();

                                yyOption1  = yyResult.index;
                                yyOpValue1 = v$el$1;
                              }
                              { // Start scope for stat.
                                StatementSequence stat = yyOpValue1;

                                yyBase = yyOption1;
                                yyC    = character(yyBase);
                                if ('E' == yyC) {
                                  yyIndex = yyOption1 + 1;

                                  yyC = character(yyIndex);
                                  if ('N' == yyC) {
                                    yyIndex = yyIndex + 1;

                                    yyC = character(yyIndex);
                                    if ('D' == yyC) {
                                      yyIndex = yyIndex + 1;

                                      yyResult = pSpacing(yyIndex);
                                      yyError  = yyResult.select(yyError);
                                      if (yyResult.hasValue()) {

                                        yyResult = pIdent(yyResult.index);
                                        yyError  = yyResult.select(yyError);
                                        if (yyResult.hasValue()) {

                                          yyBase = yyResult.index;
                                          yyC    = character(yyBase);
                                          if ('.' == yyC) {
                                            yyIndex = yyResult.index + 1;

                                            yyResult = pSpacing(yyIndex);
                                            yyError  = 
                                              yyResult.select(yyError);
                                            if (yyResult.hasValue()) {

                                              yyResult = 
                                                pEndOfFile(yyResult.index);
                                              yyError  = 
                                                yyResult.select(yyError);
                                              if (yyResult.hasValue()) {

                                                if (stat == null) stat = new StatementSequence(new ArrayList<Statement>());
                                                yyValue = new Module(ident, decl, stat);

                                                return yyResult.createValue(yyValue, yyError);
                                              }
                                            }
                                          } else {
                                            yyError = yyError.select("'.' expected", yyBase);
                                          }
                                        }
                                      }
                                    } else {
                                      yyError = yyError.select("'END' expected", yyBase);
                                    }
                                  } else {
                                    yyError = yyError.select("'END' expected", yyBase);
                                  }
                                } else {
                                  yyError = yyError.select("'END' expected", yyBase);
                                }
                              } // End scope for stat.
                            }
                          }
                        } else {
                          yyError = yyError.select("';' expected", yyBase);
                        }
                      }
                    }
                  }
                } else {
                  yyError = yyError.select("'MODULE' expected", yyBase);
                }
              } else {
                yyError = yyError.select("'MODULE' expected", yyBase);
              }
            } else {
              yyError = yyError.select("'MODULE' expected", yyBase);
            }
          } else {
            yyError = yyError.select("'MODULE' expected", yyBase);
          }
        } else {
          yyError = yyError.select("'MODULE' expected", yyBase);
        }
      } else {
        yyError = yyError.select("'MODULE' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.Module$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pModule$$Choice1(final int yyStart) throws IOException {
    int               yyC;
    int               yyIndex;
    Result            yyResult;
    StatementSequence yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('B' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('E' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('G' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('I' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('N' == yyC) {
              yyIndex = yyIndex + 1;

              yyResult = pStatementSequence(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                yyValue = yyResult.semanticValue();

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("module expected", yyStart);
    return yyError;
  }

  // =========================================================================

  static {
    add(KEYWORDS, new String[] {
      "BEGIN", "END",
      "IF", "THEN", "ELSE",
      "DO", "WHILE",
      "MODULE", "PROCEDURE",
      "VAR", "CONST", "TYPE",
      "ARRAY", "RECORD", "OF",
      "AND", "OR", "MOD", "DIV"
    });
  }

  // =========================================================================

  /**
   * Add the specified values to the specified set.
   *
   * @param set The set.
   * @param values The new values.
   */
  protected static final <T> void add(Set<T> set, T[] values) {
    for (T v : values) set.add(v);
  }

  /**
   * Check whether the specified set contains the specified value.
   *
   * @param set The set.
   * @param value The value.
   * @return <code>true</code> if the set contains the value.
   */
  protected static final <T> boolean contains(Set<T> set, T value) {
    return set.contains(value);
  }

}
