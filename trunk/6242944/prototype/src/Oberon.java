// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 1.14.4,
// (C) 2004-2009 Robert Grimm,
// on Thursday, January 6, 2011 at 11:41:44 PM.
// Edit at your own risk.
// ===========================================================================

import java.io.Reader;
import java.io.IOException;

import xtc.util.Pair;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

/**
 * Packrat parser for grammar <code>Oberon</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 1.14.4, (C) 2004-2009 Robert Grimm.
 */
public final class Oberon extends ParserBase {

  // =========================================================================

  /** Memoization table column. */
  static final class OberonColumn extends Column {
    Result fIdent;
    Result fIdent$$Star1;
    Result fTerm;
    Result fSimpleExpression;
    Result fExpression;
    Result fDeclarations;
    Result fStatement;
    Result fStatementSequence;
    Result fStatementSequence$$Star1;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public Oberon(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public Oberon(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new OberonColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Space.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpace(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case ' ':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\t':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\f':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("space expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Spacing.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpacing(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pSpace(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.EndOfFile.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEndOfFile(final int yyStart) throws IOException {
    int        yyC;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if (-1 != yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyValue = null;

      return new SemanticValue(yyValue, yyStart, yyError);
    } else {
      yyError = yyError.select("end of file expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Ident.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdent(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.fIdent) yyColumn.fIdent = pIdent$1(yyStart);
    return yyColumn.fIdent;
  }

  /** Actually parse Oberon.Ident. */
  private Result pIdent$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyResult = pIdent$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("ident expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.Ident$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdent$$Star1(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.fIdent$$Star1) 
      yyColumn.fIdent$$Star1 = pIdent$$Star1$1(yyStart);
    return yyColumn.fIdent$$Star1;
  }

  /** Actually parse Oberon.Ident$$Star1. */
  private Result pIdent$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyResult = pIdent$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyResult = pIdent$$Star1(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 3.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.IntString.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntString(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("int string expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Integer.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInteger(final int yyStart) throws IOException {
    Result             yyResult;
    ast.IntegerLiteral yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIntString(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String i = yyResult.semanticValue();

      yyValue = new ast.IntegerLiteral(new Integer(i));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Term.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTerm(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.fTerm) yyColumn.fTerm = pTerm$1(yyStart);
    return yyColumn.fTerm;
  }

  /** Actually parse Oberon.Term. */
  private Result pTerm$1(final int yyStart) throws IOException {
    Result         yyResult;
    ast.Expression yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pInteger(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.SimpleExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleExpression(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.fSimpleExpression) 
      yyColumn.fSimpleExpression = pSimpleExpression$1(yyStart);
    return yyColumn.fSimpleExpression;
  }

  /** Actually parse Oberon.SimpleExpression. */
  private Result pSimpleExpression$1(final int yyStart) throws IOException {
    Result         yyResult;
    ast.Expression yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTerm(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ast.Expression lhs = yyResult.semanticValue();

      yyResult = pSimpleExpression$$Choice1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String op = yyResult.semanticValue();

        yyResult = pSimpleExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          ast.Expression rhs = yyResult.semanticValue();

          if (op == "+")
          yyValue = new ast.AddExpression(lhs, rhs);
          else //FIXME
          yyValue = new ast.SubExpression(lhs, rhs);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pTerm(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.SimpleExpression$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleExpression$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('+' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "+";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "-";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('O' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('R' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "OR";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("simple expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Expression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.fExpression) 
      yyColumn.fExpression = pExpression$1(yyStart);
    return yyColumn.fExpression;
  }

  /** Actually parse Oberon.Expression. */
  private Result pExpression$1(final int yyStart) throws IOException {
    Result         yyResult;
    ast.Expression yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSimpleExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ast.Expression lhs = yyResult.semanticValue();

      yyResult = pExpression$$Choice1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String op = yyResult.semanticValue();

        yyResult = pSimpleExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          ast.Expression rhs = yyResult.semanticValue();

          if (op == "<") yyValue = new ast.LtExpression(lhs, rhs);
          else return null; //FIXME

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pSimpleExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.Expression$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "=";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "<=";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "<";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Assignment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssignment(final int yyStart) throws IOException {
    int           yyC;
    int           yyIndex;
    Result        yyResult;
    int           yyBase;
    ast.Statement yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String lhs = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if (':' == yyC) {
          yyIndex = yyResult.index + 1;

          yyC = character(yyIndex);
          if ('=' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = pSpacing(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pExpression(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                ast.Expression rhs = yyResult.semanticValue();

                yyValue = new ast.Assignment(lhs, rhs);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } else {
            yyError = yyError.select("':=' expected", yyBase);
          }
        } else {
          yyError = yyError.select("':=' expected", yyBase);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Declaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclaration(final int yyStart) throws IOException {
    int             yyC;
    int             yyIndex;
    Result          yyResult;
    int             yyBase;
    ast.Declaration yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pProcedureDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if (';' == yyC) {
        yyIndex = yyResult.index + 1;

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Declarations.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarations(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.fDeclarations) 
      yyColumn.fDeclarations = pDeclarations$1(yyStart);
    return yyColumn.fDeclarations;
  }

  /** Actually parse Oberon.Declarations. */
  private Result pDeclarations$1(final int yyStart) throws IOException {
    Result                yyResult;
    Pair<ast.Declaration> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ast.Declaration v$el$1 = yyResult.semanticValue();

      yyResult = pDeclarations(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<ast.Declaration> v$2 = yyResult.semanticValue();

        yyValue = new Pair<ast.Declaration>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.ProcedureDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pProcedureDeclaration(final int yyStart) throws IOException {
    int                 yyC;
    int                 yyIndex;
    Result              yyResult;
    int                 yyBase;
    int                 yyOption1;
    Pair<ast.Statement> yyOpValue1;
    ast.Procedure       yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('P' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('R' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('O' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('C' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('E' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('D' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('U' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('R' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('E' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyResult = pSpacing(yyIndex);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pIdent(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          String name = yyResult.semanticValue();

                          yyBase = yyResult.index;
                          yyC    = character(yyBase);
                          if (';' == yyC) {
                            yyIndex = yyResult.index + 1;

                            yyResult = pSpacing(yyIndex);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyResult = pDeclarations(yyResult.index);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {
                                Pair<ast.Declaration> decl = yyResult.semanticValue();

                                yyResult = pSpacing(yyResult.index);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {

                                  yyOption1  = yyResult.index;
                                  yyOpValue1 = null;

                                  yyBase = yyOption1;
                                  yyC    = character(yyBase);
                                  if ('B' == yyC) {
                                    yyIndex = yyOption1 + 1;

                                    yyC = character(yyIndex);
                                    if ('E' == yyC) {
                                      yyIndex = yyIndex + 1;

                                      yyC = character(yyIndex);
                                      if ('G' == yyC) {
                                        yyIndex = yyIndex + 1;

                                        yyC = character(yyIndex);
                                        if ('I' == yyC) {
                                          yyIndex = yyIndex + 1;

                                          yyC = character(yyIndex);
                                          if ('N' == yyC) {
                                            yyIndex = yyIndex + 1;

                                            yyResult = pSpacing(yyIndex);
                                            yyError  = 
                                              yyResult.select(yyError, yyOption1);
                                            if (yyResult.hasValue()) {

                                              yyResult = 
                                                pStatementSequence(yyResult.index);
                                              yyError  = 
                                                yyResult.select(yyError, yyOption1);
                                              if (yyResult.hasValue()) {
                                                Pair<ast.Statement> v$el$1 = yyResult.semanticValue();

                                                yyOption1  = yyResult.index;
                                                yyOpValue1 = v$el$1;
                                              }
                                            }
                                          } else {
                                            yyError = yyError.select("'BEGIN' expected", yyBase);
                                          }
                                        } else {
                                          yyError = yyError.select("'BEGIN' expected", yyBase);
                                        }
                                      } else {
                                        yyError = yyError.select("'BEGIN' expected", yyBase);
                                      }
                                    } else {
                                      yyError = yyError.select("'BEGIN' expected", yyBase);
                                    }
                                  } else {
                                    yyError = yyError.select("'BEGIN' expected", yyBase);
                                  }
                                  { // Start scope for stat.
                                    Pair<ast.Statement> stat = yyOpValue1;

                                    yyResult = pSpacing(yyOption1);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {

                                      yyBase = yyResult.index;
                                      yyC    = character(yyBase);
                                      if ('E' == yyC) {
                                        yyIndex = yyResult.index + 1;

                                        yyC = character(yyIndex);
                                        if ('N' == yyC) {
                                          yyIndex = yyIndex + 1;

                                          yyC = character(yyIndex);
                                          if ('D' == yyC) {
                                            yyIndex = yyIndex + 1;

                                            yyResult = pSpacing(yyIndex);
                                            yyError  = 
                                              yyResult.select(yyError);
                                            if (yyResult.hasValue()) {

                                              yyResult = 
                                                pIdent(yyResult.index);
                                              yyError  = 
                                                yyResult.select(yyError);
                                              if (yyResult.hasValue()) {

                                                yyResult = 
                                                  pSpacing(yyResult.index);
                                                yyError  = 
                                                  yyResult.select(yyError);
                                                if (yyResult.hasValue()) {

                                                  if (stat == null)
                                                  stat = Pair.EMPTY;
                                                  yyValue = new ast.Procedure(name, stat.list());

                                                  return yyResult.createValue(yyValue, yyError);
                                                }
                                              }
                                            }
                                          } else {
                                            yyError = yyError.select("'END' expected", yyBase);
                                          }
                                        } else {
                                          yyError = yyError.select("'END' expected", yyBase);
                                        }
                                      } else {
                                        yyError = yyError.select("'END' expected", yyBase);
                                      }
                                    }
                                  } // End scope for stat.
                                }
                              }
                            }
                          } else {
                            yyError = yyError.select("';' expected", yyBase);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("procedure declaration expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.ActualParameters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pActualParameters(final int yyStart) throws IOException {
    int                  yyC;
    int                  yyIndex;
    Result               yyResult;
    int                  yyBase;
    int                  yyRepetition1;
    Pair<ast.Expression> yyRepValue1;
    Pair<ast.Expression> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pExpression(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        ast.Expression expr1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase = yyRepetition1;
          yyC    = character(yyBase);
          if (',' == yyC) {
            yyIndex = yyRepetition1 + 1;

            yyResult = pExpression(yyIndex);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              ast.Expression v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<ast.Expression>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }
        { // Start scope for expr2.
          Pair<ast.Expression> expr2 = yyRepValue1.reverse();

          yyBase = yyRepetition1;
          yyC    = character(yyBase);
          if (')' == yyC) {
            yyIndex = yyRepetition1 + 1;

            yyValue = new Pair<ast.Expression>(expr1, expr2);

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        } // End scope for expr2.
      }
    }

    // Done.
    yyError = yyError.select("actual parameters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.ProcedureCall.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pProcedureCall(final int yyStart) throws IOException {
    Result            yyResult;
    ast.ProcedureCall yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String name = yyResult.semanticValue();

      yyResult = pActualParameters(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<ast.Expression> params = yyResult.semanticValue();

        yyValue = new ast.ProcedureCall(name, params.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Statement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pStatement(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.fStatement) 
      yyColumn.fStatement = pStatement$1(yyStart);
    return yyColumn.fStatement;
  }

  /** Actually parse Oberon.Statement. */
  private Result pStatement$1(final int yyStart) throws IOException {
    Result        yyResult;
    ast.Statement yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAssignment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pProcedureCall(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.StatementSequence.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStatementSequence(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.fStatementSequence) 
      yyColumn.fStatementSequence = pStatementSequence$1(yyStart);
    return yyColumn.fStatementSequence;
  }

  /** Actually parse Oberon.StatementSequence. */
  private Result pStatementSequence$1(final int yyStart) throws IOException {
    Result              yyResult;
    Pair<ast.Statement> yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pStatement(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        ast.Statement s1 = yyResult.semanticValue();

        yyResult = pStatementSequence$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<ast.Statement> s2 = yyResult.semanticValue();

          yyValue = new Pair(s1, s2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.StatementSequence$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStatementSequence$$Star1(final int yyStart) 
    throws IOException {

    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.fStatementSequence$$Star1) 
      yyColumn.fStatementSequence$$Star1 = pStatementSequence$$Star1$1(yyStart);
    return yyColumn.fStatementSequence$$Star1;
  }

  /** Actually parse Oberon.StatementSequence$$Star1. */
  private Result pStatementSequence$$Star1$1(final int yyStart) 
    throws IOException {

    int                 yyC;
    int                 yyIndex;
    Result              yyResult;
    int                 yyBase;
    Pair<ast.Statement> yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if (';' == yyC) {
        yyIndex = yyResult.index + 1;

        yyResult = pSpacing(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pStatement(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            ast.Statement v$el$1 = yyResult.semanticValue();

            yyResult = pStatementSequence$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<ast.Statement> v$2 = yyResult.semanticValue();

              yyValue = new Pair<ast.Statement>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Module.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pModule(final int yyStart) throws IOException {
    int                 yyC;
    int                 yyIndex;
    Result              yyResult;
    int                 yyBase;
    int                 yyOption1;
    Pair<ast.Statement> yyOpValue1;
    ast.Node            yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('M' == yyC) {
        yyIndex = yyResult.index + 1;

        yyC = character(yyIndex);
        if ('O' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('D' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('U' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('L' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('E' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyResult = pSpacing(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pIdent(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      String ident = yyResult.semanticValue();

                      yyResult = pSpacing(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyBase = yyResult.index;
                        yyC    = character(yyBase);
                        if (';' == yyC) {
                          yyIndex = yyResult.index + 1;

                          yyResult = pSpacing(yyIndex);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pDeclarations(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {
                              Pair<ast.Declaration> decl = yyResult.semanticValue();

                              yyOption1  = yyResult.index;
                              yyOpValue1 = null;

                              yyBase = yyOption1;
                              yyC    = character(yyBase);
                              if ('B' == yyC) {
                                yyIndex = yyOption1 + 1;

                                yyC = character(yyIndex);
                                if ('E' == yyC) {
                                  yyIndex = yyIndex + 1;

                                  yyC = character(yyIndex);
                                  if ('G' == yyC) {
                                    yyIndex = yyIndex + 1;

                                    yyC = character(yyIndex);
                                    if ('I' == yyC) {
                                      yyIndex = yyIndex + 1;

                                      yyC = character(yyIndex);
                                      if ('N' == yyC) {
                                        yyIndex = yyIndex + 1;

                                        yyResult = 
                                          pStatementSequence(yyIndex);
                                        yyError  = 
                                          yyResult.select(yyError, yyOption1);
                                        if (yyResult.hasValue()) {
                                          Pair<ast.Statement> v$el$1 = yyResult.semanticValue();

                                          yyOption1  = yyResult.index;
                                          yyOpValue1 = v$el$1;
                                        }
                                      } else {
                                        yyError = yyError.select("'BEGIN' expected", yyBase);
                                      }
                                    } else {
                                      yyError = yyError.select("'BEGIN' expected", yyBase);
                                    }
                                  } else {
                                    yyError = yyError.select("'BEGIN' expected", yyBase);
                                  }
                                } else {
                                  yyError = yyError.select("'BEGIN' expected", yyBase);
                                }
                              } else {
                                yyError = yyError.select("'BEGIN' expected", yyBase);
                              }
                              { // Start scope for stat.
                                Pair<ast.Statement> stat = yyOpValue1;

                                yyBase = yyOption1;
                                yyC    = character(yyBase);
                                if ('E' == yyC) {
                                  yyIndex = yyOption1 + 1;

                                  yyC = character(yyIndex);
                                  if ('N' == yyC) {
                                    yyIndex = yyIndex + 1;

                                    yyC = character(yyIndex);
                                    if ('D' == yyC) {
                                      yyIndex = yyIndex + 1;

                                      yyResult = pSpacing(yyIndex);
                                      yyError  = yyResult.select(yyError);
                                      if (yyResult.hasValue()) {

                                        yyResult = pIdent(yyResult.index);
                                        yyError  = yyResult.select(yyError);
                                        if (yyResult.hasValue()) {

                                          yyBase = yyResult.index;
                                          yyC    = character(yyBase);
                                          if ('.' == yyC) {
                                            yyIndex = yyResult.index + 1;

                                            yyResult = pEndOfFile(yyIndex);
                                            yyError  = 
                                              yyResult.select(yyError);
                                            if (yyResult.hasValue()) {

                                              yyValue = new ast.Module(ident, decl.list(), stat.list());

                                              return yyResult.createValue(yyValue, yyError);
                                            }
                                          } else {
                                            yyError = yyError.select("'.' expected", yyBase);
                                          }
                                        }
                                      }
                                    } else {
                                      yyError = yyError.select("'END' expected", yyBase);
                                    }
                                  } else {
                                    yyError = yyError.select("'END' expected", yyBase);
                                  }
                                } else {
                                  yyError = yyError.select("'END' expected", yyBase);
                                }
                              } // End scope for stat.
                            }
                          }
                        } else {
                          yyError = yyError.select("';' expected", yyBase);
                        }
                      }
                    }
                  }
                } else {
                  yyError = yyError.select("'MODULE' expected", yyBase);
                }
              } else {
                yyError = yyError.select("'MODULE' expected", yyBase);
              }
            } else {
              yyError = yyError.select("'MODULE' expected", yyBase);
            }
          } else {
            yyError = yyError.select("'MODULE' expected", yyBase);
          }
        } else {
          yyError = yyError.select("'MODULE' expected", yyBase);
        }
      } else {
        yyError = yyError.select("'MODULE' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

}
