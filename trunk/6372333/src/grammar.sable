Package oberon;
Helpers 
    /* Our helpers */
    all = [0 .. 0xFFFF]; 
	lowercase = ['a' .. 'z'];
	uppercase = ['A' .. 'Z'];
	number = ['0' .. '9'];
    sp = ' ' ; 
    nl = 10 ;
    
   	cr = 13;
	lf = 10;
	next_line = 0x85;
	line_separator = 0x2028;
	paragraph_separator = 0x2029;
	horizontal_tab = 9;
	newline = cr | lf | cr lf | next_line | line_separator | paragraph_separator;
    
    plus = '+' sp*;
    min = '-' sp*;   
     
    ortxt = 'OR' sp*;
    
    letter = lowercase | uppercase; 
  
Tokens 
    /* Our simple token definition(s). */
    dot = '.';  
    l_bkt = '[';
	l_brc = '{';
	l_par = '(';
	r_bkt = ']';
	r_brc = '}';
	r_par = ')' sp*;
	tilde = '~';
        
    exeq = '=';
    exha = '#';
    exst = '<';
    exse = '<=';
    exgt = '>';
    exge = '>=';
	
	comma = ',';
	colon = ':';
	
	ass = ':=' sp*;  
    semi = ';' nl?;
        
    moduletxt = 'MODULE' sp*;
    consttxt = 'CONST' sp*;
    typetxt = 'TYPE' sp*;
    vartxt = 'VAR' sp*;
    begintxt = 'BEGIN' sp*;
    endtxt = 'END' sp*;
    recordtxt = 'RECORD' sp*;
    arraytxt = 'ARRAY' sp*;
    oftxt = 'OF' sp*;
    whiletxt = 'WHILE' sp*;
    dotxt = 'DO' sp*;
    iftxt = 'IF' sp*;
    thentxt = 'THEN' sp*;
    elsiftxt = 'ELSIF' sp*;
    elsetxt = 'ELSE' sp*;
    proceduretxt = 'PROCEDURE' sp*;
    sptxt = sp;

	plusorminusoror =
		plus |
		min |
		ortxt;
 	plusorminus = 
		plus |
		min; 
		
	mult = '*' sp*;
    mod = 'MOD' sp*;
    amp = '&' sp*;
    div = 'DIV' sp*;
 	
    integer = number+ sp*;
    identifier = letter (letter | number)* sp*;
    
    blank_newline = newline*;
    blank_whitespace = sp*;
    tab = horizontal_tab;
    
Ignored Tokens  
	blank_newline, blank_whitespace, tab;  
    
Productions 
    program = moduletxt [beginid]:identifier semi declarations begstat? endtxt [endid]:identifier dot;
    
    declarations = constdecl? typedecl? vardecl? proceduredeclaration*;
    begstat = begintxt sptxt* statementsequence;
    
    constdecl = consttxt constdeclaration+;
    typedecl = typetxt typedeclaration+;
    vardecl = vartxt vardeclaration+;
    assignment = identifier ass expression;
    constdeclaration = identifier exeq sptxt* expression semi;
    typedeclaration = identifier exeq sptxt* type semi;
    statementsequence = statement andstatement*;
    vardeclaration = identlist colon sptxt* type semi;
    
    expression = simpleexpression simpleexpressionevaluation?; 
    type = 
    	{idtype} identifier | 
    	{arrtype} arraytype | 
    	{rectype} recordtype;
    proceduredeclaration = procedureheading [beginsemi]:semi procedurebody identifier [endsemi]:semi;
    statement = 
    	{statass} assignment |
    	{statproc} procedurecall | 
    	{statif} ifstatement |
    	{statwhi} whilestatement;
    identlist = identifier andidentifier*;
    andstatement = semi sptxt* statement;
    
    andidentifier = comma sptxt* identifier;
    simpleexpressionevaluation = expressionoperator sptxt* simpleexpression;
    simpleexpression = plusorminus? term moreterms*;
    recordtype = recordtxt fieldlist morefields endtxt;
    arraytype = arraytxt expression oftxt type;
    whilestatement = whiletxt expression dotxt statementsequence endtxt;
    ifstatement = iftxt expression thentxt statementsequence elsif? else? endtxt; 
    procedurecall = identifier actualparams*; 
    procedureheading = proceduretxt identifier formalparams?;
    procedurebody = declarations procedurebodystatements? endtxt; 
   
 	term = factor sptxt* additionaloperations*;
 	moreterms = plusorminusoror term;
	fieldlist = 
		{fieldlist} identlist colon type |
		{listnone} sptxt; 
	morefields = semi fieldlist;
	elsif = elsiftxt expression thentxt statementsequence;
	else = elsetxt statementsequence; 
	actualparams = l_par actualparameters? r_par;
	formalparams = l_par formalparameters? r_par;
	procedurebodystatements = begintxt statementsequence;
   
   	additionaloperations = termoperator sptxt* factor;
    factor = 
    	{intfactor} integer | 
    	{expfactor} l_par expression r_par |
    	{tilfactor} tilde factor |
    	{idfactor} identifier selector;
   	actualparameters = expression moreactualparameters*;
   	formalparameters = fpsection sptxt* moreformalparameters*;
   
	selector = realselector*;
	termoperator = 
		{temmult} mult | 
		{termdiv} div | 
		{termmod} mod | 
		{termamp} amp; 

    realselector = 
    	{dotselector} dot identifier |
    	{arrselector} l_bkt expression r_bkt;
   	fpsection = vartxt? identlist colon sptxt* type;
	moreactualparameters = comma sptxt* expression;
	moreformalparameters = semi sptxt* fpsection; 
	
	
    expressionoperator = 
   		{exequ} exeq |
   		{exhas} exha |
   		{exgrt} exgt |
   		{exgre} exge |
   		{exsmt} exst |
   		{exsme} exse;