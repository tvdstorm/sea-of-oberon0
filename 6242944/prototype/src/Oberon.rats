module Oberon;

header {
	import xtc.util.Action;
	import java.util.*;
}
// NOTE: a mess, need to clean this up

transient String Digit = [0-9];
transient String Letter = [A-Za-z];

transient void Space = ' ' / '\t' / '\f' ;
transient void Spacing = Space*;
transient void EndOfFile = !_ ;

String Ident = Letter (Letter / Digit)*;

transient String IntString = Digit+;


ast.IntegerLiteral Integer = 
	i:IntString
	{ yyValue = new ast.IntegerLiteral(new Integer(i)); }
	;

ast.Identifier Identifier = 
	ident:Ident Spacing
	{ yyValue = new ast.Identifier(ident); }
	;

ast.Expression Factor = 
 	  Identifier
	/ Integer Spacing
	;

ast.Expression Term = Factor;

//FIXME: try to clean this up somehow
constant Action<ast.Expression> SimpleExpressionTail =
	op:("+" / "-") rhs:Term 
		{
          yyValue = new Action<ast.Expression>() {
            public ast.Expression run(ast.Expression lhs) {
            	ast.Expression result = null;
            	if (op == "+") result = new ast.AddExpression(lhs, rhs);
            	if (op == "-") result = new ast.SubExpression(lhs, rhs);
            	return result;
            }};
      	}
	;

ast.Expression SimpleExpression =
	seed:Term actions:SimpleExpressionTail*
		{ yyValue = apply(actions, seed); }
	/
	Term
	;

ast.Expression Expression = 
	  lhs:SimpleExpression op:("=" / "<=" / "<") rhs:SimpleExpression
		{ if (op == "<") yyValue = new ast.LtExpression(lhs, rhs);
		  else return null; //FIXME
		}
	/ SimpleExpression
	;
	
ast.Statement Assignment = 
	lhs:Ident Spacing ":=" Spacing rhs:Expression
	{ yyValue = new ast.Assignment(lhs, rhs); }
	;

ast.Declaration Declaration = 
	;

ast.ConstDeclaration ConstDeclaration = 
	ident:Ident 
	void:Spacing 
	void:"=" 
	void:Spacing 
	expr:Expression 
	void:";" 
	void:Spacing
	{ yyValue = new ast.ConstDeclaration(ident, expr); }
	;

ast.Declarations Declarations = 
	consts:(void:"CONST" void:Spacing ConstDeclaration*)?
	procs:(ProcedureDeclaration void:";")*
	{ 	List<ast.Declaration> decls = new ArrayList<ast.Declaration>();
		consts.addTo(decls);
		yyValue = new ast.Declarations(decls); 
	}
	;

ast.Procedure ProcedureDeclaration = 
	"PROCEDURE" Spacing name:Ident ";" 
	Spacing
	decl:Declarations
	Spacing
	stat:(void:"BEGIN" Spacing StatementSequence)? 
	Spacing
	"END" Spacing 
	Ident Spacing
	{	yyValue = new ast.Procedure(name, stat);  }
	;

public Pair<ast.Expression> ActualParameters = 
	void:"(" expr1:Expression expr2:(void:"," Expression)* void:")"
	{ yyValue = new Pair<ast.Expression>(expr1, expr2); }
	;

public ast.ProcedureCall ProcedureCall = 
	name:Ident params:ActualParameters
	{ yyValue = new ast.ProcedureCall(name, params.list()); }
	;

public ast.Node ElseTail = 
	  void:"ELSE" StatementSequence
	/ void:"ELSIF" Spacing expr:Expression 
	  void:"THEN"
	  stat1:StatementSequence
	  stat2:ElseTail? 
	  { yyValue = new ast.IfStatement(expr, stat1, stat2); }
	;

public ast.IfStatement IfStatement = 
	void:"IF" Spacing expr:Expression 
	void:"THEN" 
	stat1:StatementSequence
	stat2:ElseTail?
	void:"END"
	{ yyValue = new ast.IfStatement(expr, stat1, stat2); }
	;

public ast.WhileStatement WhileStatement =
	void:"WHILE" Spacing expr:Expression
	void:"DO"
	stat:StatementSequence
	void:"END"
	{ yyValue = new ast.WhileStatement(expr, stat); }
	;

public ast.Statement Statement = 
	  Assignment Spacing 
	/ IfStatement Spacing
	/ WhileStatement Spacing
	/ ProcedureCall Spacing
	;

ast.StatementSequence StatementSequence = 
	void:Spacing
	s1:Statement
	s2:(void:Spacing void:";" void:Spacing Statement)*
	{ yyValue = new ast.StatementSequence((new Pair(s1, s2)).list()); } //FIXME
	;

public ast.Node Module = 
	Spacing 
	"MODULE" Spacing ident:Ident Spacing ";" 
	Spacing
	decl:Declarations
	stat:(void:"BEGIN" StatementSequence)?
	"END" void:Spacing void:Ident void:"."
	EndOfFile
	{  yyValue = new ast.Module(ident, decl, stat);  }
	;

