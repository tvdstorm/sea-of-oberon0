module Oberon;

header {
	import xtc.util.Action;
	import java.util.*;
}
// NOTE: a mess, need to clean this up

transient String Digit = [0-9];
transient String Letter = [A-Za-z];

transient void Space = ' ' / '\t' / '\f' ;
transient void Spacing = Space*;
transient void EndOfFile = !_ ;

String Ident = Letter (Letter / Digit)*;

transient String IntString = Digit+;


ast.IntegerLiteral Integer = 
	i:IntString
	{ yyValue = new ast.IntegerLiteral(new Integer(i)); }
	;

ast.Identifier Identifier = 
	ident:Ident Spacing
	{ yyValue = new ast.Identifier(ident); }
	;

//FIXME: use Action here?
ast.Expression IdentifierSelector = 
	ident:Identifier
	exprs:(void:"[" Expression void:"]")*
	{ 
		List<ast.Expression> list = exprs.list();
		ast.Expression expr = ident;
		for(int i=0; i<list.size(); i++) {
			expr = new ast.Selector(expr, list.get(i));
		}
		yyValue = expr;
	}
	;

ast.Expression Factor = 
 	  IdentifierSelector
	/ Integer Spacing
	;

ast.Expression Term = Factor;

//FIXME: try to clean this up somehow
constant Action<ast.Expression> SimpleExpressionTail =
	op:("+" / "-") rhs:Term 
		{
          yyValue = new Action<ast.Expression>() {
            public ast.Expression run(ast.Expression lhs) {
            	ast.Expression result = null;
            	if (op == "+") result = new ast.AddExpression(lhs, rhs);
            	if (op == "-") result = new ast.SubExpression(lhs, rhs);
            	return result;
            }};
      	}
	;

ast.Expression SimpleExpression =
	seed:Term actions:SimpleExpressionTail*
		{ yyValue = apply(actions, seed); }
	/
	Term
	;

ast.Expression Expression = 
	  lhs:SimpleExpression op:("=" / "<=" / "<") rhs:SimpleExpression
		{ if (op == "<") yyValue = new ast.LtExpression(lhs, rhs);
		  else return null; //FIXME
		}
	/ SimpleExpression
	;
	
ast.Statement Assignment = 
	lhs:IdentifierSelector Spacing ":=" Spacing rhs:Expression
	{ yyValue = new ast.Assignment(lhs, rhs); }
	;

ast.IdentifierType IdentifierType = 
	ident:Ident void:Spacing
	{ yyValue = new ast.IdentifierType(ident); }
	;

ast.ArrayType ArrayType = 
	void:"ARRAY" void:Spacing 
	length:Expression void:Spacing
	void:"OF" void:Spacing type:Type
	{ yyValue = new ast.ArrayType(length, type); }
	;

ast.Type Type = ArrayType / IdentifierType;

Pair<String> IdentList = 
	ident1:Ident void:Spacing 
	ident2:(void:"," void:Spacing Ident void:Spacing)*
	{ yyValue = new Pair<String>(ident1, ident2); }
	;

ast.ConstDeclaration ConstDeclaration = 
	ident:Ident void:Spacing 
	void:"=" void:Spacing 
	expr:Expression void:";" void:Spacing
	{ yyValue = new ast.ConstDeclaration(ident, expr); }
	;

ast.VarDeclaration VarDeclaration = 
	idents:IdentList void:Spacing 
	void:":" void:Spacing 
	type:Type void:Spacing
	void:";" void:Spacing
	{ yyValue = new ast.VarDeclaration(idents.list(), type); }
	;

ast.Declarations Declarations = 
	consts:(void:"CONST" void:Spacing ConstDeclaration*)?
	vars:(void:"VAR" void:Spacing VarDeclaration*)?
	procs:(ProcedureDeclaration void:";")*
	{ 	List<ast.Declaration> decls = new ArrayList<ast.Declaration>();
		if (consts != null) consts.addTo(decls);
		if (vars != null) vars.addTo(decls);
		if (procs != null) procs.addTo(decls);
		yyValue = new ast.Declarations(decls); 
	}
	;

List<ast.Parameter> FPSection = 
	names:IdentList Spacing ":" Spacing type:Type
	{ 
		List<ast.Parameter> list = new ArrayList<ast.Parameter>();
		for(int i=0; i<names.size(); i++) {
			list.add(new ast.Parameter(names.get(i), type));
		}
		yyValue = list;
	}
	;

List<ast.Parameter> FormalParameters = 
	"(" args1:FPSection? args2:(void:";" FPSection)* ")"
	{ 	List<ast.Parameter> params = new ArrayList<ast.Parameter>();
		if (args1 != null) params.addAll(args1);
		if (args2 != null) {
			for(List<ast.Parameter> l : args2.list())
				params.addAll(l);
		}
		yyValue = params;
	}
	;

ast.Procedure ProcedureDeclaration = 
	"PROCEDURE" Spacing name:Ident params:FormalParameters ";" 
	Spacing
	decl:Declarations
	Spacing
	stat:(void:"BEGIN" Spacing StatementSequence)? 
	Spacing
	"END" Spacing 
	Ident Spacing
	{	yyValue = new ast.Procedure(name, decl, stat);  }
	;

public Pair<ast.Expression> ActualParameters = 
	void:"(" expr1:Expression expr2:(void:"," Expression)* void:")"
	{ yyValue = new Pair<ast.Expression>(expr1, expr2); }
	;

public ast.ProcedureCall ProcedureCall = 
	name:Ident params:ActualParameters
	{ yyValue = new ast.ProcedureCall(name, params.list()); }
	;

public ast.Node ElseTail = 
	  void:"ELSE" StatementSequence
	/ void:"ELSIF" Spacing expr:Expression 
	  void:"THEN"
	  stat1:StatementSequence
	  stat2:ElseTail? 
	  { yyValue = new ast.IfStatement(expr, stat1, stat2); }
	;

public ast.IfStatement IfStatement = 
	void:"IF" Spacing expr:Expression 
	void:"THEN" 
	stat1:StatementSequence
	stat2:ElseTail?
	void:"END"
	{ yyValue = new ast.IfStatement(expr, stat1, stat2); }
	;

public ast.WhileStatement WhileStatement =
	void:"WHILE" Spacing expr:Expression
	void:"DO"
	stat:StatementSequence
	void:"END"
	{ yyValue = new ast.WhileStatement(expr, stat); }
	;

public ast.Statement Statement = 
	  Assignment Spacing 
	/ IfStatement Spacing
	/ WhileStatement Spacing
	/ ProcedureCall Spacing
	;

ast.StatementSequence StatementSequence = 
	void:Spacing
	s1:Statement
	s2:(void:Spacing void:";" void:Spacing Statement)*
	{ yyValue = new ast.StatementSequence((new Pair(s1, s2)).list()); } //FIXME
	;

public ast.Node Module = 
	Spacing 
	"MODULE" Spacing ident:Ident Spacing ";" 
	Spacing
	decl:Declarations
	stat:(void:"BEGIN" StatementSequence)?
	"END" void:Spacing void:Ident void:"."
	EndOfFile
	{  yyValue = new ast.Module(ident, decl, stat);  }
	;

