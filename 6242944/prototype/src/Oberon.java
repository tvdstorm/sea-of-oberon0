// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 1.14.4,
// (C) 2004-2009 Robert Grimm,
// on Monday, January 10, 2011 at 2:47:09 PM.
// Edit at your own risk.
// ===========================================================================

import java.io.Reader;
import java.io.IOException;

import xtc.util.Pair;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

import xtc.util.Action;
import java.util.*;

/**
 * Packrat parser for grammar <code>Oberon</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 1.14.4, (C) 2004-2009 Robert Grimm.
 */
public final class Oberon extends ParserBase {

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result fIdent;
    Result fIdent$$Star1;
    Result fIdentifierSelector;
    Result fIdentifierSelector$$Star1;
    Result fTerm;
    Result fSimpleExpression;
    Result fSimpleExpression$$Star1;
    Result fExpression;
    Result fType;
    Result fIdentList;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fIdentList$$Star1;
    Result fDeclarations;
    Result fDeclarations$$Star1;
    Result fDeclarations$$Star2;
    Result fDeclarations$$Star3;
    Result fFPSection;
    Result fElseTail;
    Result fStatement;
    Result fStatementSequence;
    Result fStatementSequence$$Star1;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class OberonColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public Oberon(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public Oberon(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new OberonColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Space.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpace(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case ' ':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\t':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\f':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("space expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Spacing.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpacing(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pSpace(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.EndOfFile.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEndOfFile(final int yyStart) throws IOException {
    int        yyC;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if (-1 != yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyValue = null;

      return new SemanticValue(yyValue, yyStart, yyError);
    } else {
      yyError = yyError.select("end of file expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Ident.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdent(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fIdent) 
      yyColumn.chunk1.fIdent = pIdent$1(yyStart);
    return yyColumn.chunk1.fIdent;
  }

  /** Actually parse Oberon.Ident. */
  private Result pIdent$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyResult = pIdent$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("ident expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.Ident$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdent$$Star1(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fIdent$$Star1) 
      yyColumn.chunk1.fIdent$$Star1 = pIdent$$Star1$1(yyStart);
    return yyColumn.chunk1.fIdent$$Star1;
  }

  /** Actually parse Oberon.Ident$$Star1. */
  private Result pIdent$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyResult = pIdent$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyResult = pIdent$$Star1(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 3.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.IntString.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntString(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("int string expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Integer.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInteger(final int yyStart) throws IOException {
    Result             yyResult;
    ast.IntegerLiteral yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIntString(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String i = yyResult.semanticValue();

      yyValue = new ast.IntegerLiteral(new Integer(i));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Identifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentifier(final int yyStart) throws IOException {
    Result         yyResult;
    ast.Identifier yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String ident = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = new ast.Identifier(ident);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.IdentifierSelector.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentifierSelector(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fIdentifierSelector) 
      yyColumn.chunk1.fIdentifierSelector = pIdentifierSelector$1(yyStart);
    return yyColumn.chunk1.fIdentifierSelector;
  }

  /** Actually parse Oberon.IdentifierSelector. */
  private Result pIdentifierSelector$1(final int yyStart) throws IOException {
    Result         yyResult;
    ast.Expression yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ast.Identifier ident = yyResult.semanticValue();

      yyResult = pIdentifierSelector$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<ast.Expression> exprs = yyResult.semanticValue();

        List<ast.Expression> list = exprs.list();
        ast.Expression expr = ident;
        for(int i=0; i<list.size(); i++) {
          expr = new ast.Selector(expr, list.get(i));
        }
        yyValue = expr;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.IdentifierSelector$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentifierSelector$$Star1(final int yyStart) 
    throws IOException {

    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fIdentifierSelector$$Star1) 
      yyColumn.chunk1.fIdentifierSelector$$Star1 = pIdentifierSelector$$Star1$1(yyStart);
    return yyColumn.chunk1.fIdentifierSelector$$Star1;
  }

  /** Actually parse Oberon.IdentifierSelector$$Star1. */
  private Result pIdentifierSelector$$Star1$1(final int yyStart) 
    throws IOException {

    int                  yyC;
    int                  yyIndex;
    Result               yyResult;
    int                  yyBase;
    Pair<ast.Expression> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('[' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pExpression(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        ast.Expression v$el$1 = yyResult.semanticValue();

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if (']' == yyC) {
          yyIndex = yyResult.index + 1;

          yyResult = pIdentifierSelector$$Star1(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<ast.Expression> v$2 = yyResult.semanticValue();

            yyValue = new Pair<ast.Expression>(v$el$1, v$2);

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Factor.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFactor(final int yyStart) throws IOException {
    Result         yyResult;
    ast.Expression yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifierSelector(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pInteger(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Term.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTerm(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fTerm) 
      yyColumn.chunk1.fTerm = pTerm$1(yyStart);
    return yyColumn.chunk1.fTerm;
  }

  /** Actually parse Oberon.Term. */
  private Result pTerm$1(final int yyStart) throws IOException {
    Result         yyResult;
    ast.Expression yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFactor(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.SimpleExpressionTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleExpressionTail(final int yyStart) throws IOException {
    Result                 yyResult;
    Action<ast.Expression> yyValue;
    ParseError             yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSimpleExpressionTail$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String op = yyResult.semanticValue();

      yyResult = pTerm(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final ast.Expression rhs = yyResult.semanticValue();

        yyValue = new Action<ast.Expression>() {
          public ast.Expression run(ast.Expression lhs) {
            ast.Expression result = null;
            if (op == "+") result = new ast.AddExpression(lhs, rhs);
            if (op == "-") result = new ast.SubExpression(lhs, rhs);
            return result;
        }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.SimpleExpressionTail$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleExpressionTail$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('+' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "+";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "-";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("simple expression tail expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.SimpleExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleExpression(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fSimpleExpression) 
      yyColumn.chunk1.fSimpleExpression = pSimpleExpression$1(yyStart);
    return yyColumn.chunk1.fSimpleExpression;
  }

  /** Actually parse Oberon.SimpleExpression. */
  private Result pSimpleExpression$1(final int yyStart) throws IOException {
    Result         yyResult;
    ast.Expression yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTerm(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ast.Expression seed = yyResult.semanticValue();

      yyResult = pSimpleExpression$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<ast.Expression>> actions = yyResult.semanticValue();

        yyValue = apply(actions, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pTerm(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.SimpleExpression$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleExpression$$Star1(final int yyStart) 
    throws IOException {

    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fSimpleExpression$$Star1) 
      yyColumn.chunk1.fSimpleExpression$$Star1 = pSimpleExpression$$Star1$1(yyStart);
    return yyColumn.chunk1.fSimpleExpression$$Star1;
  }

  /** Actually parse Oberon.SimpleExpression$$Star1. */
  private Result pSimpleExpression$$Star1$1(final int yyStart) 
    throws IOException {

    Result                       yyResult;
    Pair<Action<ast.Expression>> yyValue;
    ParseError                   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSimpleExpressionTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<ast.Expression> v$el$2 = yyResult.semanticValue();

      yyResult = pSimpleExpression$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<ast.Expression>> v$3 = yyResult.semanticValue();

        yyValue = new Pair<Action<ast.Expression>>(v$el$2, v$3);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Expression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExpression) 
      yyColumn.chunk1.fExpression = pExpression$1(yyStart);
    return yyColumn.chunk1.fExpression;
  }

  /** Actually parse Oberon.Expression. */
  private Result pExpression$1(final int yyStart) throws IOException {
    Result         yyResult;
    ast.Expression yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSimpleExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ast.Expression lhs = yyResult.semanticValue();

      yyResult = pExpression$$Choice1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String op = yyResult.semanticValue();

        yyResult = pSimpleExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          ast.Expression rhs = yyResult.semanticValue();

          if (op == "<") yyValue = new ast.LtExpression(lhs, rhs);
          else return null; //FIXME

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pSimpleExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.Expression$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "=";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "<=";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "<";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Assignment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssignment(final int yyStart) throws IOException {
    int           yyC;
    int           yyIndex;
    Result        yyResult;
    int           yyBase;
    ast.Statement yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifierSelector(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ast.Expression lhs = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if (':' == yyC) {
          yyIndex = yyResult.index + 1;

          yyC = character(yyIndex);
          if ('=' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = pSpacing(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pExpression(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                ast.Expression rhs = yyResult.semanticValue();

                yyValue = new ast.Assignment(lhs, rhs);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } else {
            yyError = yyError.select("':=' expected", yyBase);
          }
        } else {
          yyError = yyError.select("':=' expected", yyBase);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.IdentifierType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentifierType(final int yyStart) throws IOException {
    Result             yyResult;
    ast.IdentifierType yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String ident = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = new ast.IdentifierType(ident);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.ArrayType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArrayType(final int yyStart) throws IOException {
    int           yyC;
    int           yyIndex;
    Result        yyResult;
    int           yyBase;
    ast.ArrayType yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('A' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('R' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('R' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('A' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('Y' == yyC) {
              yyIndex = yyIndex + 1;

              yyResult = pSpacing(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pExpression(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  ast.Expression length = yyResult.semanticValue();

                  yyResult = pSpacing(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyBase = yyResult.index;
                    yyC    = character(yyBase);
                    if ('O' == yyC) {
                      yyIndex = yyResult.index + 1;

                      yyC = character(yyIndex);
                      if ('F' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyResult = pSpacing(yyIndex);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pType(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {
                            ast.Type type = yyResult.semanticValue();

                            yyValue = new ast.ArrayType(length, type);

                            return yyResult.createValue(yyValue, yyError);
                          }
                        }
                      } else {
                        yyError = yyError.select("'OF' expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("'OF' expected", yyBase);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("array type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Type.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fType) 
      yyColumn.chunk1.fType = pType$1(yyStart);
    return yyColumn.chunk1.fType;
  }

  /** Actually parse Oberon.Type. */
  private Result pType$1(final int yyStart) throws IOException {
    Result     yyResult;
    ast.Type   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pArrayType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pIdentifierType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.IdentList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentList(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fIdentList) 
      yyColumn.chunk1.fIdentList = pIdentList$1(yyStart);
    return yyColumn.chunk1.fIdentList;
  }

  /** Actually parse Oberon.IdentList. */
  private Result pIdentList$1(final int yyStart) throws IOException {
    Result       yyResult;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String ident1 = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdentList$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<String> ident2 = yyResult.semanticValue();

          yyValue = new Pair<String>(ident1, ident2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.IdentList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentList$$Star1(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fIdentList$$Star1) 
      yyColumn.chunk2.fIdentList$$Star1 = pIdentList$$Star1$1(yyStart);
    return yyColumn.chunk2.fIdentList$$Star1;
  }

  /** Actually parse Oberon.IdentList$$Star1. */
  private Result pIdentList$$Star1$1(final int yyStart) throws IOException {
    int          yyC;
    int          yyIndex;
    Result       yyResult;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpacing(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdent(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$1 = yyResult.semanticValue();

          yyResult = pSpacing(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pIdentList$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<String> v$2 = yyResult.semanticValue();

              yyValue = new Pair<String>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.ConstDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConstDeclaration(final int yyStart) throws IOException {
    int                  yyC;
    int                  yyIndex;
    Result               yyResult;
    int                  yyBase;
    ast.ConstDeclaration yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String ident = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if ('=' == yyC) {
          yyIndex = yyResult.index + 1;

          yyResult = pSpacing(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              ast.Expression expr = yyResult.semanticValue();

              yyBase = yyResult.index;
              yyC    = character(yyBase);
              if (';' == yyC) {
                yyIndex = yyResult.index + 1;

                yyResult = pSpacing(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = new ast.ConstDeclaration(ident, expr);

                  return yyResult.createValue(yyValue, yyError);
                }
              } else {
                yyError = yyError.select("';' expected", yyBase);
              }
            }
          }
        } else {
          yyError = yyError.select("'=' expected", yyBase);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.VarDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVarDeclaration(final int yyStart) throws IOException {
    int                yyC;
    int                yyIndex;
    Result             yyResult;
    int                yyBase;
    ast.VarDeclaration yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentList(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<String> idents = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if (':' == yyC) {
          yyIndex = yyResult.index + 1;

          yyResult = pSpacing(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pType(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              ast.Type type = yyResult.semanticValue();

              yyResult = pSpacing(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyBase = yyResult.index;
                yyC    = character(yyBase);
                if (';' == yyC) {
                  yyIndex = yyResult.index + 1;

                  yyResult = pSpacing(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyValue = new ast.VarDeclaration(idents.list(), type);

                    return yyResult.createValue(yyValue, yyError);
                  }
                } else {
                  yyError = yyError.select("';' expected", yyBase);
                }
              }
            }
          }
        } else {
          yyError = yyError.select("':' expected", yyBase);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Declarations.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarations(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fDeclarations) 
      yyColumn.chunk2.fDeclarations = pDeclarations$1(yyStart);
    return yyColumn.chunk2.fDeclarations;
  }

  /** Actually parse Oberon.Declarations. */
  private Result pDeclarations$1(final int yyStart) throws IOException {
    int              yyC;
    int              yyIndex;
    Result           yyResult;
    int              yyBase;
    int              yyOption1;
    Object           yyOpValue1;
    ast.Declarations yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyBase = yyOption1;
    yyC    = character(yyBase);
    if ('C' == yyC) {
      yyIndex = yyOption1 + 1;

      yyC = character(yyIndex);
      if ('O' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('N' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('S' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('T' == yyC) {
              yyIndex = yyIndex + 1;

              yyResult = pSpacing(yyIndex);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {

                yyResult = pDeclarations$$Star1(yyResult.index);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {
                  Pair<ast.ConstDeclaration> v$el$1 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$1;
                }
              }
            } else {
              yyError = yyError.select("'CONST' expected", yyBase);
            }
          } else {
            yyError = yyError.select("'CONST' expected", yyBase);
          }
        } else {
          yyError = yyError.select("'CONST' expected", yyBase);
        }
      } else {
        yyError = yyError.select("'CONST' expected", yyBase);
      }
    } else {
      yyError = yyError.select("'CONST' expected", yyBase);
    }
    { // Start scope for consts.
      Pair<ast.ConstDeclaration> consts = cast(yyOpValue1);

      yyOpValue1 = null;

      yyBase = yyOption1;
      yyC    = character(yyBase);
      if ('V' == yyC) {
        yyIndex = yyOption1 + 1;

        yyC = character(yyIndex);
        if ('A' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('R' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = pSpacing(yyIndex);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {

              yyResult = pDeclarations$$Star2(yyResult.index);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {
                Pair<ast.VarDeclaration> v$el$4 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$4;
              }
            }
          } else {
            yyError = yyError.select("'VAR' expected", yyBase);
          }
        } else {
          yyError = yyError.select("'VAR' expected", yyBase);
        }
      } else {
        yyError = yyError.select("'VAR' expected", yyBase);
      }
      { // Start scope for vars.
        Pair<ast.VarDeclaration> vars = cast(yyOpValue1);

        yyResult = pDeclarations$$Star3(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<ast.Procedure> procs = yyResult.semanticValue();

          List<ast.Declaration> decls = new ArrayList<ast.Declaration>();
          if (consts != null) consts.addTo(decls);
          if (vars != null) vars.addTo(decls);
          if (procs != null) procs.addTo(decls);
          yyValue = new ast.Declarations(decls);

          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for vars.
    } // End scope for consts.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.Declarations$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarations$$Star1(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fDeclarations$$Star1) 
      yyColumn.chunk2.fDeclarations$$Star1 = pDeclarations$$Star1$1(yyStart);
    return yyColumn.chunk2.fDeclarations$$Star1;
  }

  /** Actually parse Oberon.Declarations$$Star1. */
  private Result pDeclarations$$Star1$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    Pair<ast.ConstDeclaration> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pConstDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ast.ConstDeclaration v$el$2 = yyResult.semanticValue();

      yyResult = pDeclarations$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<ast.ConstDeclaration> v$3 = yyResult.semanticValue();

        yyValue = new Pair<ast.ConstDeclaration>(v$el$2, v$3);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.Declarations$$Star2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarations$$Star2(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fDeclarations$$Star2) 
      yyColumn.chunk2.fDeclarations$$Star2 = pDeclarations$$Star2$1(yyStart);
    return yyColumn.chunk2.fDeclarations$$Star2;
  }

  /** Actually parse Oberon.Declarations$$Star2. */
  private Result pDeclarations$$Star2$1(final int yyStart) 
    throws IOException {

    Result                   yyResult;
    Pair<ast.VarDeclaration> yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pVarDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ast.VarDeclaration v$el$5 = yyResult.semanticValue();

      yyResult = pDeclarations$$Star2(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<ast.VarDeclaration> v$6 = yyResult.semanticValue();

        yyValue = new Pair<ast.VarDeclaration>(v$el$5, v$6);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.Declarations$$Star3.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarations$$Star3(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fDeclarations$$Star3) 
      yyColumn.chunk2.fDeclarations$$Star3 = pDeclarations$$Star3$1(yyStart);
    return yyColumn.chunk2.fDeclarations$$Star3;
  }

  /** Actually parse Oberon.Declarations$$Star3. */
  private Result pDeclarations$$Star3$1(final int yyStart) 
    throws IOException {

    int                 yyC;
    int                 yyIndex;
    Result              yyResult;
    int                 yyBase;
    Pair<ast.Procedure> yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pProcedureDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ast.Procedure v$el$7 = yyResult.semanticValue();

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if (';' == yyC) {
        yyIndex = yyResult.index + 1;

        yyResult = pDeclarations$$Star3(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<ast.Procedure> v$8 = yyResult.semanticValue();

          yyValue = new Pair<ast.Procedure>(v$el$7, v$8);

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.FPSection.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFPSection(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fFPSection) 
      yyColumn.chunk2.fFPSection = pFPSection$1(yyStart);
    return yyColumn.chunk2.fFPSection;
  }

  /** Actually parse Oberon.FPSection. */
  private Result pFPSection$1(final int yyStart) throws IOException {
    int                 yyC;
    int                 yyIndex;
    Result              yyResult;
    int                 yyBase;
    List<ast.Parameter> yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentList(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<String> names = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if (':' == yyC) {
          yyIndex = yyResult.index + 1;

          yyResult = pSpacing(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pType(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              ast.Type type = yyResult.semanticValue();

              List<ast.Parameter> list = new ArrayList<ast.Parameter>();
              for(int i=0; i<names.size(); i++) {
                list.add(new ast.Parameter(names.get(i), type));
              }
              yyValue = list;

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } else {
          yyError = yyError.select("':' expected", yyBase);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.FormalParameters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFormalParameters(final int yyStart) throws IOException {
    int                       yyC;
    int                       yyIndex;
    Result                    yyResult;
    int                       yyBase;
    int                       yyRepetition1;
    Pair<List<ast.Parameter>> yyRepValue1;
    int                       yyOption1;
    List<ast.Parameter>       yyOpValue1;
    List<ast.Parameter>       yyValue;
    ParseError                yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyOption1  = yyIndex;
      yyOpValue1 = null;

      yyResult = pFPSection(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        List<ast.Parameter> v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for args1.
        List<ast.Parameter> args1 = yyOpValue1;

        yyRepetition1 = yyOption1;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase = yyRepetition1;
          yyC    = character(yyBase);
          if (';' == yyC) {
            yyIndex = yyRepetition1 + 1;

            yyResult = pFPSection(yyIndex);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              List<ast.Parameter> v$el$2 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = 
                new Pair<List<ast.Parameter>>(v$el$2, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
          break;
        }
        { // Start scope for args2.
          Pair<List<ast.Parameter>> args2 = yyRepValue1.reverse();

          yyBase = yyRepetition1;
          yyC    = character(yyBase);
          if (')' == yyC) {
            yyIndex = yyRepetition1 + 1;

            List<ast.Parameter> params = new ArrayList<ast.Parameter>();
            if (args1 != null) params.addAll(args1);
            if (args2 != null) {
              for(List<ast.Parameter> l : args2.list())
              params.addAll(l);
            }
            yyValue = params;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        } // End scope for args2.
      } // End scope for args1.
    }

    // Done.
    yyError = yyError.select("formal parameters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.ProcedureDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pProcedureDeclaration(final int yyStart) throws IOException {
    int                   yyC;
    int                   yyIndex;
    Result                yyResult;
    int                   yyBase;
    int                   yyOption1;
    ast.StatementSequence yyOpValue1;
    ast.Procedure         yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('P' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('R' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('O' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('C' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('E' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('D' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('U' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('R' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('E' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyResult = pSpacing(yyIndex);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pIdent(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          String name = yyResult.semanticValue();

                          yyResult = pFormalParameters(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {
                            List<ast.Parameter> params = yyResult.semanticValue();

                            yyBase = yyResult.index;
                            yyC    = character(yyBase);
                            if (';' == yyC) {
                              yyIndex = yyResult.index + 1;

                              yyResult = pSpacing(yyIndex);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyResult = pDeclarations(yyResult.index);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {
                                  ast.Declarations decl = yyResult.semanticValue();

                                  yyResult = pSpacing(yyResult.index);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyOption1  = yyResult.index;
                                    yyOpValue1 = null;

                                    yyBase = yyOption1;
                                    yyC    = character(yyBase);
                                    if ('B' == yyC) {
                                      yyIndex = yyOption1 + 1;

                                      yyC = character(yyIndex);
                                      if ('E' == yyC) {
                                        yyIndex = yyIndex + 1;

                                        yyC = character(yyIndex);
                                        if ('G' == yyC) {
                                          yyIndex = yyIndex + 1;

                                          yyC = character(yyIndex);
                                          if ('I' == yyC) {
                                            yyIndex = yyIndex + 1;

                                            yyC = character(yyIndex);
                                            if ('N' == yyC) {
                                              yyIndex = yyIndex + 1;

                                              yyResult = pSpacing(yyIndex);
                                              yyError  = 
                                                yyResult.select(yyError, yyOption1);
                                              if (yyResult.hasValue()) {

                                                yyResult = 
                                                  pStatementSequence(yyResult.index);
                                                yyError  = 
                                                  yyResult.select(yyError, yyOption1);
                                                if (yyResult.hasValue()) {
                                                  ast.StatementSequence v$el$1 = yyResult.semanticValue();

                                                  yyOption1  = yyResult.index;
                                                  yyOpValue1 = v$el$1;
                                                }
                                              }
                                            } else {
                                              yyError = yyError.select("'BEGIN' expected", yyBase);
                                            }
                                          } else {
                                            yyError = yyError.select("'BEGIN' expected", yyBase);
                                          }
                                        } else {
                                          yyError = yyError.select("'BEGIN' expected", yyBase);
                                        }
                                      } else {
                                        yyError = yyError.select("'BEGIN' expected", yyBase);
                                      }
                                    } else {
                                      yyError = yyError.select("'BEGIN' expected", yyBase);
                                    }
                                    { // Start scope for stat.
                                      ast.StatementSequence stat = yyOpValue1;

                                      yyResult = pSpacing(yyOption1);
                                      yyError  = yyResult.select(yyError);
                                      if (yyResult.hasValue()) {

                                        yyBase = yyResult.index;
                                        yyC    = character(yyBase);
                                        if ('E' == yyC) {
                                          yyIndex = yyResult.index + 1;

                                          yyC = character(yyIndex);
                                          if ('N' == yyC) {
                                            yyIndex = yyIndex + 1;

                                            yyC = character(yyIndex);
                                            if ('D' == yyC) {
                                              yyIndex = yyIndex + 1;

                                              yyResult = pSpacing(yyIndex);
                                              yyError  = 
                                                yyResult.select(yyError);
                                              if (yyResult.hasValue()) {

                                                yyResult = 
                                                  pIdent(yyResult.index);
                                                yyError  = 
                                                  yyResult.select(yyError);
                                                if (yyResult.hasValue()) {

                                                  yyResult = 
                                                    pSpacing(yyResult.index);
                                                  yyError  = 
                                                    yyResult.select(yyError);
                                                  if (yyResult.hasValue()) {

                                                    yyValue = new ast.Procedure(name, decl, stat);

                                                    return yyResult.createValue(yyValue, yyError);
                                                  }
                                                }
                                              }
                                            } else {
                                              yyError = yyError.select("'END' expected", yyBase);
                                            }
                                          } else {
                                            yyError = yyError.select("'END' expected", yyBase);
                                          }
                                        } else {
                                          yyError = yyError.select("'END' expected", yyBase);
                                        }
                                      }
                                    } // End scope for stat.
                                  }
                                }
                              }
                            } else {
                              yyError = yyError.select("';' expected", yyBase);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("procedure declaration expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.ActualParameters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pActualParameters(final int yyStart) throws IOException {
    int                  yyC;
    int                  yyIndex;
    Result               yyResult;
    int                  yyBase;
    int                  yyRepetition1;
    Pair<ast.Expression> yyRepValue1;
    Pair<ast.Expression> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pExpression(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        ast.Expression expr1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase = yyRepetition1;
          yyC    = character(yyBase);
          if (',' == yyC) {
            yyIndex = yyRepetition1 + 1;

            yyResult = pExpression(yyIndex);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              ast.Expression v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<ast.Expression>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }
        { // Start scope for expr2.
          Pair<ast.Expression> expr2 = yyRepValue1.reverse();

          yyBase = yyRepetition1;
          yyC    = character(yyBase);
          if (')' == yyC) {
            yyIndex = yyRepetition1 + 1;

            yyValue = new Pair<ast.Expression>(expr1, expr2);

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        } // End scope for expr2.
      }
    }

    // Done.
    yyError = yyError.select("actual parameters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.ProcedureCall.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pProcedureCall(final int yyStart) throws IOException {
    Result            yyResult;
    ast.ProcedureCall yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String name = yyResult.semanticValue();

      yyResult = pActualParameters(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<ast.Expression> params = yyResult.semanticValue();

        yyValue = new ast.ProcedureCall(name, params.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.ElseTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pElseTail(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fElseTail) 
      yyColumn.chunk2.fElseTail = pElseTail$1(yyStart);
    return yyColumn.chunk2.fElseTail;
  }

  /** Actually parse Oberon.ElseTail. */
  private Result pElseTail$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    ast.Node   yyOpValue1;
    ast.Node   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('E' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('L' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('S' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('E' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = pStatementSequence(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              yyValue = yyResult.semanticValue();

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('E' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('L' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('S' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('I' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('F' == yyC) {
              yyIndex = yyIndex + 1;

              yyResult = pSpacing(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pExpression(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  ast.Expression expr = yyResult.semanticValue();

                  yyBase = yyResult.index;
                  yyC    = character(yyBase);
                  if ('T' == yyC) {
                    yyIndex = yyResult.index + 1;

                    yyC = character(yyIndex);
                    if ('H' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('E' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('N' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyResult = pStatementSequence(yyIndex);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {
                            ast.StatementSequence stat1 = yyResult.semanticValue();

                            yyOption1  = yyResult.index;
                            yyOpValue1 = null;

                            yyResult = pElseTail(yyOption1);
                            yyError  = yyResult.select(yyError, yyOption1);
                            if (yyResult.hasValue()) {
                              ast.Node v$el$2 = yyResult.semanticValue();

                              yyOption1  = yyResult.index;
                              yyOpValue1 = v$el$2;
                            }
                            { // Start scope for stat2.
                              ast.Node stat2 = yyOpValue1;

                              yyValue = new ast.IfStatement(expr, stat1, stat2);

                              return new SemanticValue(yyValue, yyOption1, yyError);
                            } // End scope for stat2.
                          }
                        } else {
                          yyError = yyError.select("'THEN' expected", yyBase);
                        }
                      } else {
                        yyError = yyError.select("'THEN' expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("'THEN' expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("'THEN' expected", yyBase);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("else tail expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.IfStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pIfStatement(final int yyStart) throws IOException {
    int             yyC;
    int             yyIndex;
    Result          yyResult;
    int             yyBase;
    int             yyOption1;
    ast.Node        yyOpValue1;
    ast.IfStatement yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('I' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('F' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pSpacing(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            ast.Expression expr = yyResult.semanticValue();

            yyBase = yyResult.index;
            yyC    = character(yyBase);
            if ('T' == yyC) {
              yyIndex = yyResult.index + 1;

              yyC = character(yyIndex);
              if ('H' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('E' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('N' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyResult = pStatementSequence(yyIndex);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      ast.StatementSequence stat1 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = null;

                      yyResult = pElseTail(yyOption1);
                      yyError  = yyResult.select(yyError, yyOption1);
                      if (yyResult.hasValue()) {
                        ast.Node v$el$1 = yyResult.semanticValue();

                        yyOption1  = yyResult.index;
                        yyOpValue1 = v$el$1;
                      }
                      { // Start scope for stat2.
                        ast.Node stat2 = yyOpValue1;

                        yyBase = yyOption1;
                        yyC    = character(yyBase);
                        if ('E' == yyC) {
                          yyIndex = yyOption1 + 1;

                          yyC = character(yyIndex);
                          if ('N' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('D' == yyC) {
                              yyIndex = yyIndex + 1;

                              yyValue = new ast.IfStatement(expr, stat1, stat2);

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            } else {
                              yyError = yyError.select("'END' expected", yyBase);
                            }
                          } else {
                            yyError = yyError.select("'END' expected", yyBase);
                          }
                        } else {
                          yyError = yyError.select("'END' expected", yyBase);
                        }
                      } // End scope for stat2.
                    }
                  } else {
                    yyError = yyError.select("'THEN' expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("'THEN' expected", yyBase);
                }
              } else {
                yyError = yyError.select("'THEN' expected", yyBase);
              }
            } else {
              yyError = yyError.select("'THEN' expected", yyBase);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("if statement expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.WhileStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pWhileStatement(final int yyStart) throws IOException {
    int                yyC;
    int                yyIndex;
    Result             yyResult;
    int                yyBase;
    ast.WhileStatement yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('W' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('H' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('I' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('L' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('E' == yyC) {
              yyIndex = yyIndex + 1;

              yyResult = pSpacing(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pExpression(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  ast.Expression expr = yyResult.semanticValue();

                  yyBase = yyResult.index;
                  yyC    = character(yyBase);
                  if ('D' == yyC) {
                    yyIndex = yyResult.index + 1;

                    yyC = character(yyIndex);
                    if ('O' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyResult = pStatementSequence(yyIndex);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        ast.StatementSequence stat = yyResult.semanticValue();

                        yyBase = yyResult.index;
                        yyC    = character(yyBase);
                        if ('E' == yyC) {
                          yyIndex = yyResult.index + 1;

                          yyC = character(yyIndex);
                          if ('N' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('D' == yyC) {
                              yyIndex = yyIndex + 1;

                              yyValue = new ast.WhileStatement(expr, stat);

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            } else {
                              yyError = yyError.select("'END' expected", yyBase);
                            }
                          } else {
                            yyError = yyError.select("'END' expected", yyBase);
                          }
                        } else {
                          yyError = yyError.select("'END' expected", yyBase);
                        }
                      }
                    } else {
                      yyError = yyError.select("'DO' expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("'DO' expected", yyBase);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("while statement expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Statement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pStatement(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fStatement) 
      yyColumn.chunk2.fStatement = pStatement$1(yyStart);
    return yyColumn.chunk2.fStatement;
  }

  /** Actually parse Oberon.Statement. */
  private Result pStatement$1(final int yyStart) throws IOException {
    Result        yyResult;
    ast.Statement yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAssignment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pIfStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pWhileStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyResult = pProcedureCall(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.StatementSequence.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStatementSequence(final int yyStart) throws IOException {
    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fStatementSequence) 
      yyColumn.chunk2.fStatementSequence = pStatementSequence$1(yyStart);
    return yyColumn.chunk2.fStatementSequence;
  }

  /** Actually parse Oberon.StatementSequence. */
  private Result pStatementSequence$1(final int yyStart) throws IOException {
    Result                yyResult;
    ast.StatementSequence yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pStatement(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        ast.Statement s1 = yyResult.semanticValue();

        yyResult = pStatementSequence$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<ast.Statement> s2 = yyResult.semanticValue();

          yyValue = new ast.StatementSequence((new Pair(s1, s2)).list());

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Oberon.StatementSequence$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStatementSequence$$Star1(final int yyStart) 
    throws IOException {

    OberonColumn yyColumn = (OberonColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fStatementSequence$$Star1) 
      yyColumn.chunk2.fStatementSequence$$Star1 = pStatementSequence$$Star1$1(yyStart);
    return yyColumn.chunk2.fStatementSequence$$Star1;
  }

  /** Actually parse Oberon.StatementSequence$$Star1. */
  private Result pStatementSequence$$Star1$1(final int yyStart) 
    throws IOException {

    int                 yyC;
    int                 yyIndex;
    Result              yyResult;
    int                 yyBase;
    Pair<ast.Statement> yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if (';' == yyC) {
        yyIndex = yyResult.index + 1;

        yyResult = pSpacing(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pStatement(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            ast.Statement v$el$1 = yyResult.semanticValue();

            yyResult = pStatementSequence$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<ast.Statement> v$2 = yyResult.semanticValue();

              yyValue = new Pair<ast.Statement>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Oberon.Module.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pModule(final int yyStart) throws IOException {
    int                   yyC;
    int                   yyIndex;
    Result                yyResult;
    int                   yyBase;
    int                   yyOption1;
    ast.StatementSequence yyOpValue1;
    ast.Node              yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('M' == yyC) {
        yyIndex = yyResult.index + 1;

        yyC = character(yyIndex);
        if ('O' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('D' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('U' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('L' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('E' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyResult = pSpacing(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pIdent(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      String ident = yyResult.semanticValue();

                      yyResult = pSpacing(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyBase = yyResult.index;
                        yyC    = character(yyBase);
                        if (';' == yyC) {
                          yyIndex = yyResult.index + 1;

                          yyResult = pSpacing(yyIndex);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pDeclarations(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {
                              ast.Declarations decl = yyResult.semanticValue();

                              yyOption1  = yyResult.index;
                              yyOpValue1 = null;

                              yyBase = yyOption1;
                              yyC    = character(yyBase);
                              if ('B' == yyC) {
                                yyIndex = yyOption1 + 1;

                                yyC = character(yyIndex);
                                if ('E' == yyC) {
                                  yyIndex = yyIndex + 1;

                                  yyC = character(yyIndex);
                                  if ('G' == yyC) {
                                    yyIndex = yyIndex + 1;

                                    yyC = character(yyIndex);
                                    if ('I' == yyC) {
                                      yyIndex = yyIndex + 1;

                                      yyC = character(yyIndex);
                                      if ('N' == yyC) {
                                        yyIndex = yyIndex + 1;

                                        yyResult = 
                                          pStatementSequence(yyIndex);
                                        yyError  = 
                                          yyResult.select(yyError, yyOption1);
                                        if (yyResult.hasValue()) {
                                          ast.StatementSequence v$el$1 = yyResult.semanticValue();

                                          yyOption1  = yyResult.index;
                                          yyOpValue1 = v$el$1;
                                        }
                                      } else {
                                        yyError = yyError.select("'BEGIN' expected", yyBase);
                                      }
                                    } else {
                                      yyError = yyError.select("'BEGIN' expected", yyBase);
                                    }
                                  } else {
                                    yyError = yyError.select("'BEGIN' expected", yyBase);
                                  }
                                } else {
                                  yyError = yyError.select("'BEGIN' expected", yyBase);
                                }
                              } else {
                                yyError = yyError.select("'BEGIN' expected", yyBase);
                              }
                              { // Start scope for stat.
                                ast.StatementSequence stat = yyOpValue1;

                                yyBase = yyOption1;
                                yyC    = character(yyBase);
                                if ('E' == yyC) {
                                  yyIndex = yyOption1 + 1;

                                  yyC = character(yyIndex);
                                  if ('N' == yyC) {
                                    yyIndex = yyIndex + 1;

                                    yyC = character(yyIndex);
                                    if ('D' == yyC) {
                                      yyIndex = yyIndex + 1;

                                      yyResult = pSpacing(yyIndex);
                                      yyError  = yyResult.select(yyError);
                                      if (yyResult.hasValue()) {

                                        yyResult = pIdent(yyResult.index);
                                        yyError  = yyResult.select(yyError);
                                        if (yyResult.hasValue()) {

                                          yyBase = yyResult.index;
                                          yyC    = character(yyBase);
                                          if ('.' == yyC) {
                                            yyIndex = yyResult.index + 1;

                                            yyResult = pEndOfFile(yyIndex);
                                            yyError  = 
                                              yyResult.select(yyError);
                                            if (yyResult.hasValue()) {

                                              yyValue = new ast.Module(ident, decl, stat);

                                              return yyResult.createValue(yyValue, yyError);
                                            }
                                          } else {
                                            yyError = yyError.select("'.' expected", yyBase);
                                          }
                                        }
                                      }
                                    } else {
                                      yyError = yyError.select("'END' expected", yyBase);
                                    }
                                  } else {
                                    yyError = yyError.select("'END' expected", yyBase);
                                  }
                                } else {
                                  yyError = yyError.select("'END' expected", yyBase);
                                }
                              } // End scope for stat.
                            }
                          }
                        } else {
                          yyError = yyError.select("';' expected", yyBase);
                        }
                      }
                    }
                  }
                } else {
                  yyError = yyError.select("'MODULE' expected", yyBase);
                }
              } else {
                yyError = yyError.select("'MODULE' expected", yyBase);
              }
            } else {
              yyError = yyError.select("'MODULE' expected", yyBase);
            }
          } else {
            yyError = yyError.select("'MODULE' expected", yyBase);
          }
        } else {
          yyError = yyError.select("'MODULE' expected", yyBase);
        }
      } else {
        yyError = yyError.select("'MODULE' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

}
